<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="theme-color" content="#123456"><meta name="generator" content="Hexo 4.2.0"><meta><title>最近的Redis笔记 - Zeroornull</title><link rel="manifest" href="/manifest.json"><meta name="theme-color" content="#3273dc"><meta name="application-name" content="zeroornull"><meta name="msapplication-TileImage" content="icons/touch-icon-iphone.png"><meta name="msapplication-TileColor" content="#3273dc"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="zeroornull"><meta name="apple-mobile-web-app-status-bar-style" content="default"><link rel="apple-touch-icon" sizes="144x144" href="icons/touch-icon-iphone.png"><link rel="apple-touch-icon" sizes="152x152" href="icons/touch-icon-ipad.png"><link rel="apple-touch-icon" sizes="72x72" href="icon/logo.ico"><link rel="apple-touch-icon" sizes="96x96" href="icon/logo.ico"><link rel="apple-touch-icon" sizes="128x128" href="icon/logo.ico"><link rel="apple-touch-icon" sizes="256x256" href="icon/logo.ico"><meta name="description" content="最近的Redis笔记"><meta property="og:type" content="blog"><meta property="og:title" content="最近的Redis笔记"><meta property="og:url" content="https://zeroornull.github.io/2021/05/16/redis%E7%AC%94%E8%AE%B0/"><meta property="og:site_name" content="Zeroornull"><meta property="og:description" content="最近的Redis笔记"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://gitee.com/penno/blogimg/raw/master/img/20210519233337.png"><meta property="og:image" content="https://gitee.com/penno/blogimg/raw/master/img/20210519234652.png"><meta property="og:image" content="https://gitee.com/penno/blogimg/raw/master/img/20210519234708.png"><meta property="og:image" content="https://gitee.com/penno/blogimg/raw/master/img/20210524003422.png"><meta property="og:image" content="https://gitee.com/penno/blogimg/raw/master/img/20210524003506.png"><meta property="og:image" content="https://gitee.com/penno/blogimg/raw/master/img/20210524003544.png"><meta property="og:image" content="https://gitee.com/penno/blogimg/raw/master/img/20210524003557.png"><meta property="og:image" content="https://gitee.com/penno/blogimg/raw/master/img/20210525180124.png"><meta property="og:image" content="https://gitee.com/penno/blogimg/raw/master/img/20210526010744.png"><meta property="og:image" content="https://gitee.com/penno/blogimg/raw/master/img/20210526165224.png"><meta property="article:published_time" content="2021-05-16T10:05:26.000Z"><meta property="article:modified_time" content="2021-08-02T05:48:44.427Z"><meta property="article:author" content="Zeroornull"><meta property="article:tag" content="redis"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://gitee.com/penno/blogimg/raw/master/img/20210519233337.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://zeroornull.github.io/2021/05/16/redis%E7%AC%94%E8%AE%B0/"},"headline":"最近的Redis笔记","image":["https://gitee.com/penno/blogimg/raw/master/img/20210519233337.png","https://gitee.com/penno/blogimg/raw/master/img/20210519234652.png","https://gitee.com/penno/blogimg/raw/master/img/20210519234708.png","https://gitee.com/penno/blogimg/raw/master/img/20210524003422.png","https://gitee.com/penno/blogimg/raw/master/img/20210524003506.png","https://gitee.com/penno/blogimg/raw/master/img/20210524003544.png","https://gitee.com/penno/blogimg/raw/master/img/20210524003557.png","https://gitee.com/penno/blogimg/raw/master/img/20210525180124.png","https://gitee.com/penno/blogimg/raw/master/img/20210526010744.png","https://gitee.com/penno/blogimg/raw/master/img/20210526165224.png"],"datePublished":"2021-05-16T10:05:26.000Z","dateModified":"2021-08-02T05:48:44.427Z","author":{"@type":"Person","name":"Zeroornull"},"description":"最近的Redis笔记"}</script><link rel="canonical" href="https://zeroornull.github.io/2021/05/16/redis%E7%AC%94%E8%AE%B0/"><link rel="alternate" href="/path/to/atom.xml" title="Zeroornull" type="application/atom+xml"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!-->
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">Zeroornull</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="GitHub" href="https://github.com">GitHub</a><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/zeroornull"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-05-16T10:05:26.000Z" title="2021/5/16 下午6:05:26">2021-05-16</time>发表</span><span class="level-item"><time dateTime="2021-08-02T05:48:44.427Z" title="2021/8/2 下午1:48:44">2021-08-02</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/redis/">redis</a></span><span class="level-item">2 小时读完 (大约13830个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">最近的Redis笔记</h1><div class="content"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>  最近的Redis笔记</p>
<p>​        2021-05-16 18:05:26</p>
<span id="more"></span>



<h2 id="2-Redis-简介"><a href="#2-Redis-简介" class="headerlink" title="2.Redis 简介"></a>2.Redis 简介</h2><p>Redis 是我们在互联网应用中使用最广泛的一个 NoSQL 数据库，基于 C 开发的键值对存储数据库，<br>Redis 这个名字是 Remote Dictionary Service 字母缩写。<br>很多人想到 Redis，就想到缓存。但实际上 Redis 除了缓存之外，还有许多更加丰富的使用场景。比如<br>分布式锁，限流。<br>特点：<br>支持数据持久化<br>支持多种不同的数据结构类型之间的映射<br>支持主从模式的数据备份<br>自带了发布订阅系统<br>定时器、计数器</p>
<h2 id="3-Redis-安装"><a href="#3-Redis-安装" class="headerlink" title="3.Redis 安装"></a>3.Redis 安装</h2><p>四种方式获取一个 Redis：</p>
<ol>
<li>直接编译安装（推荐使用）</li>
<li>使用 Docker</li>
<li>也可以直接安装</li>
<li>还有一个在线体验的方式，通过在线体验，可以直接使用 Redis 的功能<a target="_blank" rel="noopener" href="http://try.redis.io/">http://try.redis.io/</a></li>
</ol>
<h3 id="3-1-直接编译安装"><a href="#3-1-直接编译安装" class="headerlink" title="3.1 直接编译安装"></a>3.1 直接编译安装</h3><p>提前准备好 gcc 环境。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install gcc-c++</span><br></pre></td></tr></tbody></table></figure>

<p>接下来下载并安装 Redis:</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget http://download.redis.io/releases/redis-5.0.7.tar.gz</span><br><span class="line">tar -zxvf redis-5.0.7.tar.gz</span><br><span class="line">cd redis-5.0.7/</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></tbody></table></figure>

<p>安装完成后，启动 Redis:</p>
<p>redis-server redis.conf</p>
<p>启动成功页面如下：</p>
<p><img src="https://gitee.com/penno/blogimg/raw/master/img/20210519233337.png" alt="image-20210519233337140"></p>
<h3 id="3-2-通过-Docker-安装"><a href="#3-2-通过-Docker-安装" class="headerlink" title="3.2 通过 Docker 安装"></a>3.2 通过 Docker 安装</h3><p>Docker 安装好之后，启动 Docker ，直接运行安装命令即可：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name javaboy-redis -d -p 6379:6379 redis --requirepass 123</span><br></pre></td></tr></tbody></table></figure>

<p>Docker 上的 Redis 启动成功之后，可以从宿主机上连接（前提是宿主机上存在 redis-cli）：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -a 123</span><br></pre></td></tr></tbody></table></figure>

<p>如果宿主机上没有安装 Redis，那么也可以进入到 Docker 容器种去操作 Redis:</p>
<p>docker exec -it javaboy-redis redis-cli -a 123</p>
<h3 id="3-3-直接安装"><a href="#3-3-直接安装" class="headerlink" title="3.3 直接安装"></a>3.3 直接安装</h3><p>CentOS：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install redis</span><br></pre></td></tr></tbody></table></figure>

<p>Ubuntu:</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install redis</span><br></pre></td></tr></tbody></table></figure>

<p>Mac:</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install redis</span><br></pre></td></tr></tbody></table></figure>

<h3 id="3-4-在线体验"><a href="#3-4-在线体验" class="headerlink" title="3.4 在线体验"></a>3.4 在线体验</h3><p><a target="_blank" rel="noopener" href="http://try.redis.io/">http://try.redis.io/</a></p>
<h2 id="4-Redis-五种基本数据类型"><a href="#4-Redis-五种基本数据类型" class="headerlink" title="4. Redis 五种基本数据类型"></a>4. Redis 五种基本数据类型</h2><h3 id="4-1-Redis-启动"><a href="#4-1-Redis-启动" class="headerlink" title="4.1 Redis 启动"></a>4.1 Redis 启动</h3><p>首先，修改 redis.conf 配置文件：</p>
<p><img src="https://gitee.com/penno/blogimg/raw/master/img/20210519234652.png" alt="image-20210519234652935"></p>
<p>配置完成后，保存退出，再次通过 <code>redis-server redis.conf</code> 命令启动 Redis，此时，就是在后台启<br>动了。</p>
<p><img src="https://gitee.com/penno/blogimg/raw/master/img/20210519234708.png" alt="image-20210519234708846"></p>
<h3 id="4-2-String"><a href="#4-2-String" class="headerlink" title="4.2 String"></a>4.2 String</h3><p>String 是 Redis 里边最最简单的一种数据结构。在 Redis 中，所以的 key 都是字符串，但是，不同的<br>key 对应的 value 则具备不同的数据结构，我们所说的五种不同的数据类型，主要是指 value 的数据类<br>型不同。<br>Redis 中的字符串是动态字符串，内部是可以修改的，像 Java 中的 StringBuffer，它采用分配冗余空间<br>的方式来减少内存的频繁分配。在 Redis 内部结构中，一般实际分配的内存会大于需要的内存，当字符<br>串小于 1M 的时候，扩容都是在现有的空间基础上加倍，扩容每次扩 1M 空间，最大 512M。</p>
<ul>
<li><p>set<br>set 就是给一个 key 赋值的。</p>
</li>
<li><p>append<br>使用 append 命令时，如果 key 已经存在，则直接在对应的 value 后追加值，否则就创建新的键值对。</p>
</li>
<li><p>decr<br>可以实现对 value 的减 1 操作（前提是 value 是一个数字），如果 value 不是数字，会报错，如果<br>value 不存在，则会给一个默认的值为 0，在默认值的基础上减一。</p>
</li>
<li><p>decrby<br>和 decr 类似，但是可以自己设置步长，该命令第二个参数就是步长。</p>
</li>
<li><p>get<br>get 用来获取一个 key 的 value。</p>
</li>
<li><p>getrange<br>getrange 可以用来返回 key 对应的 value 的子串，这有点类似于 Java 里边的 substring。这个命令第<br>二个和第三个参数就是截取的起始和终止位置，其中，-1 表示最后一个字符串，-2 表示倒数第二个字符<br>串，以此类推…</p>
</li>
<li><p>getset<br>获取并更新某一个 key。</p>
</li>
<li><p>incr<br>给某一个 key 的 value 自增。</p>
</li>
<li><p>incrby<br>给某一个 key 的 value 自增，同时还可以设置步长。</p>
</li>
<li><p>incrbyfloat<br>和 incrby 类似，但是自增的步长可以设置为浮点数。</p>
</li>
<li><p>mget 和 mset<br>批量获取和批量存储</p>
</li>
</ul>
<p>ttl<br>查看 key 的有效期<br>setex<br>在给 key 设置 value 的同时，还设置过期时间。<br>psetex<br>和 setex 类似，只不过这里的时间单位是毫秒。<br>setnx<br>默认情况下， set 命令会覆盖已经存在的 key，setnx 则不会。<br>msetnx<br>批量设置。<br>setrange<br>覆盖一个已经存在的 key 的value。<br>strlen<br>查看字符串长度</p>
<h4 id="4-2-1-BIT-命令"><a href="#4-2-1-BIT-命令" class="headerlink" title="4.2.1 BIT 命令"></a>4.2.1 BIT 命令</h4><p>在 Redis 中，字符串都是以二进制的方式来存储的。例如 set k1 a，a 对应的 ASCII 码是 97，97 转为<br>二进制是 01100001，BIT 相关的命令就是对二进制进行操作的。<br>getbit<br>key 对应的 value 在 offset 处的 bit 值。<br>setbit<br>修改 key 对应的 value 在 offset 处的 bit 值<br>bitcount<br>统计二进制数据中 1 的个数。</p>
<h3 id="4-3-List"><a href="#4-3-List" class="headerlink" title="4.3 List"></a>4.3 List</h3><p>lpush<br>将所有指定的值插入到存于 key 的列表的头部。如果 key 不存在，那么在进行 push 操作前会创建一个<br>空列表。 如果 key 对应的值不是一个 list 的话，那么会返回一个错误。<br>lrange<br>返回列表指定区间内的元素。<br>rpush<br>向存于 key 的列表的尾部插入所有指定的值。<br>rpop<br>移除并返回列表的尾元素。<br>lpop</p>
<p>移除并返回列表的头元素。<br>lindex<br>返回列表中，下标为 index 的元素。<br>ltrim<br>ltrim 可以对一个列表进行修剪。<br>blpop<br>阻塞式的弹出，相当于 lpop 的阻塞版。</p>
<h3 id="4-4-Set"><a href="#4-4-Set" class="headerlink" title="4.4 Set"></a>4.4 Set</h3><p>sadd<br>添加元素到一个 key 中<br>smembers<br>获取一个 key 下的所有元素<br>srem<br>移除指定的元素<br>sismemeber<br>返回某一个成员是否在集合中<br>scard<br>返回集合的数量<br>srandmember<br>随机返回一个元素<br>spop<br>随机返回并且出栈一个元素。<br>smove<br>把一个元素从一个集合移到另一个集合中去。<br>sdiff<br>返回两个集合的差集。<br>sinter<br>返回两个集合的交集。<br>sdiffstore<br>这个类似于 sdiff ，不同的是，计算出来的结果会保存在一个新的集合中。<br>sinterstore<br>类似于 sinter，只是将计算出来的交集保存到一个新的集合中。<br>sunion<br>求并集。</p>
<p>sunionstore<br>求并集并且将结果保存到新的集合中。</p>
<h3 id="4-5-Hash"><a href="#4-5-Hash" class="headerlink" title="4.5 Hash"></a>4.5 Hash</h3><p>在 hash 结构中，key 是一个字符串，value 则是一个 key/value 键值对。<br>hset<br>添加值。<br>hget<br>获取值<br>hmset<br>批量设置<br>hmget<br>批量获取<br>hdel<br>删除一个指定的 field<br>hsetnx<br>默认情况下，如果 key 和 field 相同，会覆盖掉已有的 value，hsetnx 则不会。<br>hvals<br>获取所有的 value<br>hkeys<br>获取所有的 key<br>hgetall<br>同时获取所有的 key 和 value<br>hexists<br>返回 field 是否存在<br>hincrby<br>给指定的 value 自增<br>hincrbyfloat<br>可以自增一个浮点数<br>hlen<br>返回 某一个 key 中 value 的数量<br>hstrlen<br>返回某一个 key 中的某一个 field 的字符串长度</p>
<h3 id="4-6-ZSet"><a href="#4-6-ZSet" class="headerlink" title="4.6 ZSet"></a>4.6 ZSet</h3><p>zadd<br>将指定的元素添加到有序集合中。<br>zscore<br>返回 member 的 score 值<br>zrange<br>返回集合中的一组元素。<br>zrevrange<br>返回一组元素，但是是倒序。<br>zcard<br>返回元素个数<br>zcount<br>返回 score 在某一个区间内的元素。<br>zrangebyscore<br>按照 score 的范围返回元素。<br>zrank<br>返回元素的排名（从小到大<br>zrevrank<br>返回元素排名（从大到小<br>zincrby<br>score 自增<br>zinterstore<br>给两个集合求交集。<br>zrem<br>弹出一个元素<br>zlexcount<br>计算有序集合中成员数量<br>zrangebylex<br>返回指定区间内的成员。</p>
<h3 id="4-7-key"><a href="#4-7-key" class="headerlink" title="4.7 key"></a>4.7 key</h3><p>del<br>删除一个 key/value<br>dump<br>序列化给定的 key<br>exists</p>
<p>判断一个 key 是否存在<br>ttl<br>查看一个 key 的有效期<br>expire<br>给一个 key 设置有效期，如果 key 在过期之前被重新 set 了，则过期时间会失效。<br>persist<br>移除一个 key 的过期时间<br>keys *<br>查看所有的 key<br>pttl<br>和 ttl 一样，只不过这里返回的是毫秒</p>
<h3 id="4-8-补充"><a href="#4-8-补充" class="headerlink" title="4.8 补充"></a>4.8 补充</h3><ol>
<li>四种数据类型（list/set/zset/hash），在第一次使用时，如果容器不存在，就自动创建一个</li>
<li>四种数据类型（list/set/zset/hash），如果里边没有元素了，那么立即删除容器，释放内存。</li>
</ol>
<h2 id="5-Redis-的-Java-客户端"><a href="#5-Redis-的-Java-客户端" class="headerlink" title="5.Redis 的 Java 客户端"></a>5.Redis 的 Java 客户端</h2><h3 id="5-1-开启远程连接"><a href="#5-1-开启远程连接" class="headerlink" title="5.1 开启远程连接"></a>5.1 开启远程连接</h3><p>Redis 默认是不支持远程连接的，需要手动开启。<br>一共修改两个地方：</p>
<ol>
<li>注释掉 bind: 127.0.0.1</li>
<li>开启密码校验，去掉 requirepass 的注释<br>改完之后，保存退出，启动 Redis。</li>
</ol>
<h3 id="5-2-Jedis"><a href="#5-2-Jedis" class="headerlink" title="5.2 Jedis"></a>5.2 Jedis</h3><h4 id="5-2-1-基本使用"><a href="#5-2-1-基本使用" class="headerlink" title="5.2.1 基本使用"></a>5.2.1 基本使用</h4><p>Jedis 的 GitHub 地址：<a target="_blank" rel="noopener" href="https://github.com/xetorthio/jedis">https://github.com/xetorthio/jedis</a><br>首先创建一个普通的 Maven 项目。<br>项目创建成功后，添加 Jedis 依赖：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;redis.clients&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;jedis&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;3.2.0&lt;/version&gt;</span><br><span class="line">&lt;type&gt;jar&lt;/type&gt;</span><br><span class="line">&lt;scope&gt;compile&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>然后创建一个测试方法。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class MyJedis {</span><br><span class="line">public static void main(String[] args) {</span><br><span class="line">//1.构造一个 Jedis 对象，因为这里使用的默认端口 6379，所以不用配置端口</span><br><span class="line">Jedis jedis = new Jedis("192.168.91.128");</span><br><span class="line">//2.密码认证</span><br><span class="line">jedis.auth("javaboy");</span><br><span class="line">//3.测试是否连接成功</span><br><span class="line">String ping = jedis.ping();</span><br><span class="line">//4.返回 pong 表示连接成功</span><br><span class="line">System.out.println(ping);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>对于 Jedis 而言，一旦连接上 Redis 服务端，剩下的操作都很容易了。<br>在 Jedis 中，由于方法的 API 和 Redis 的命令高度一致，所以，Jedis 中的方法见名知意，直接使用即<br>可。</p>
<h4 id="5-2-2-连接池"><a href="#5-2-2-连接池" class="headerlink" title="5.2.2 连接池"></a>5.2.2 连接池</h4><p>在实际应用中，Jedis 实例我们一般都是通过连接池来获取，由于 Jedis 对象不是线城安全的，所以，当<br>我们使用 Jedis 对象时，从连接池获取 Jedis，使用完成之后，再还给连接池。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class JedisPoolTest {</span><br><span class="line">public static void main(String[] args) {</span><br><span class="line">//1. 构造一个 Jedis 连接池</span><br><span class="line">JedisPool pool = new JedisPool("192.168.91.128", 6379);</span><br><span class="line">//2. 从连接池中获取一个 Jedis 连接</span><br><span class="line">Jedis jedis = pool.getResource();</span><br><span class="line">//3. Jedis 操作</span><br><span class="line">String ping = jedis.ping();</span><br><span class="line">System.out.println(ping);</span><br><span class="line">//4. 归还连接</span><br><span class="line">jedis.close();</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>如果第三步抛出异常的话，会导致第四步无法执行，所以，我们要对代码进行改进，确保第四步能够执<br>行。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class JedisPoolTest {</span><br><span class="line">public static void main(String[] args) {</span><br><span class="line">Jedis jedis = null;</span><br><span class="line">//1. 构造一个 Jedis 连接池</span><br><span class="line">JedisPool pool = new JedisPool("192.168.91.128", 6379);</span><br><span class="line">//2. 从连接池中获取一个 Jedis 连接</span><br><span class="line">jedis = pool.getResource();</span><br><span class="line">jedis.auth("javaboy");</span><br><span class="line">try {</span><br><span class="line">//3. Jedis 操作</span><br><span class="line">String ping = jedis.ping();</span><br><span class="line">System.out.println(ping);</span><br><span class="line">} catch (Exception e) {</span><br><span class="line">e.printStackTrace();</span><br><span class="line">} finally {</span><br><span class="line">//4. 归还连接</span><br><span class="line">if (jedis != null) {</span><br><span class="line">jedis.close();</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>通过 finally 我们可以确保 jedis 一定被关闭。<br>利用 JDK1.7 中的 try-with-resource 特性，可以对上面的代码进行改造：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class JedisPoolTest {</span><br><span class="line">public static void main(String[] args) {</span><br><span class="line">JedisPool pool = new JedisPool("192.168.91.128");</span><br><span class="line">try(Jedis jedis = pool.getResource()) {</span><br><span class="line">jedis.auth("javaboy");</span><br><span class="line">String ping = jedis.ping();</span><br><span class="line">System.out.println(ping);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这段代码的作用和上面的是一致的。<br>但是，上面这段代码无法实现强约束。我们可以做进一步的改进：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public interface CallWithJedis {</span><br><span class="line">void call(Jedis jedis);</span><br><span class="line">}</span><br><span class="line">public class Redis {</span><br><span class="line">private JedisPool pool;</span><br><span class="line">public Redis() {</span><br><span class="line">GenericObjectPoolConfig config = new GenericObjectPoolConfig();</span><br><span class="line">//连接池最大空闲数</span><br><span class="line">config.setMaxIdle(300);</span><br><span class="line">//最大连接数</span><br><span class="line">config.setMaxTotal(1000);</span><br><span class="line">//连接最大等待时间，如果是 -1 表示没有限制</span><br><span class="line">config.setMaxWaitMillis(30000);</span><br><span class="line">//在空闲时检查有效性</span><br><span class="line">config.setTestOnBorrow(true);</span><br><span class="line">/**</span><br><span class="line">* 1. Redis 地址</span><br><span class="line">* 2. Redis 端口</span><br><span class="line">* 3. 连接超时时间</span><br><span class="line">* 4. 密码</span><br><span class="line">*/</span><br><span class="line">pool = new JedisPool(config, "192.168.91.128", 6379, 30000, "javaboy");</span><br><span class="line">}</span><br><span class="line">public void execute(CallWithJedis callWithJedis) {</span><br><span class="line">try (Jedis jedis = pool.getResource()) {</span><br><span class="line">callWithJedis.call(jedis);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">Redis redis = new Redis();</span><br><span class="line">redis.execute(jedis -&gt; {</span><br><span class="line">System.out.println(jedis.ping());</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure>

<h3 id="5-3-Lettuce"><a href="#5-3-Lettuce" class="headerlink" title="5.3 Lettuce"></a>5.3 Lettuce</h3><p>GitHub：<a target="_blank" rel="noopener" href="https://github.com/lettuce-io/lettuce-core">https://github.com/lettuce-io/lettuce-core</a><br>Lettuce 和 Jedis 的一个比较：</p>
<ol>
<li>Jedis 在实现的过程中是直接连接 Redis 的，在多个线程之间共享一个 Jedis 实例，这是线城不安<br>全的，如果想在多线程场景下使用 Jedis，就得使用连接池，这样，每个线城都有自己的 Jedis 实<br>例。</li>
<li>Lettuce 基于目前很火的 Netty NIO 框架来构建，所以克服了 Jedis 中线程不安全的问题，Lettuce<br>支持同步、异步 以及 响应式调用，多个线程可以共享一个连接实例。<br>使用 Lettuce，首先创建一个普通的 Maven 项目，添加 Lettuce 依赖：</li>
</ol>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;io.lettuce&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;lettuce-core&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;5.2.2.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>然后来一个简单的测试案例：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class LettuceTest {</span><br><span class="line">public static void main(String[] args) {</span><br><span class="line">RedisClient redisClient =</span><br><span class="line">RedisClient.create("redis://javaboy@192.168.91.128");</span><br><span class="line">StatefulRedisConnection&lt;String, String&gt; connect = redisClient.connect();</span><br><span class="line">RedisCommands&lt;String, String&gt; sync = connect.sync();</span><br><span class="line">sync.set("name", "javaboy");</span><br><span class="line">String name = sync.get("name");</span><br><span class="line">System.out.println(name);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>注意这里的密码传递方式，密码直接写在连接地址里边。</p>
<h2 id="6-Redis-做分布式锁"><a href="#6-Redis-做分布式锁" class="headerlink" title="6.Redis 做分布式锁"></a>6.Redis 做分布式锁</h2><p>分布式锁也算是 Redis 比较常见的使用场景。<br>问题场景：<br>例如一个简单的用户操作，一个线城去修改用户的状态，首先从数据库中读出用户的状态，然后<br>在内存中进行修改，修改完成后，再存回去。在单线程中，这个操作没有问题，但是在多线程<br>中，由于读取、修改、存 这是三个操作，不是原子操作，所以在多线程中，这样会出问题。<br>对于这种问题，我们可以使用分布式锁来限制程序的并发执行。</p>
<h3 id="6-1-基本用法"><a href="#6-1-基本用法" class="headerlink" title="6.1 基本用法"></a>6.1 基本用法</h3><p>分布式锁实现的思路很简单，就是进来一个线城先占位，当别的线城进来操作时，发现已经有人占位<br>了，就会放弃或者稍后再试。</p>
<p>在 Redis 中，占位一般使用 setnx 指令，先进来的线城先占位，线程的操作执行完成后，再调用 del 指<br>令释放位子。<br>根据上面的思路，我们写出的代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockTest</span> </span>{</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">Redis redis = <span class="keyword">new</span> Redis();</span><br><span class="line">redis.execute(jedis-&gt;{</span><br><span class="line">Long setnx = jedis.setnx(<span class="string">"k1"</span>, <span class="string">"v1"</span>);</span><br><span class="line"><span class="keyword">if</span> (setnx == <span class="number">1</span>) {</span><br><span class="line"><span class="comment">//没人占位</span></span><br><span class="line">jedis.set(<span class="string">"name"</span>, <span class="string">"javaboy"</span>);</span><br><span class="line">String name = jedis.get(<span class="string">"name"</span>);</span><br><span class="line">System.out.println(name);</span><br><span class="line">jedis.del(<span class="string">"k1"</span>);<span class="comment">//释放资源</span></span><br><span class="line">}<span class="keyword">else</span>{</span><br><span class="line"><span class="comment">//有人占位，停止/暂缓 操作</span></span><br><span class="line">}</span><br><span class="line">});</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>上面的代码存在一个小小问题：如果代码业务执行的过程中抛异常或者挂了，这样会导致 del 指令没有<br>被调用，这样，k1 无法释放，后面来的请求全部堵塞在这里，锁也永远得不到释放。<br>要解决这个问题，我们可以给锁添加一个过期时间，确保锁在一定的时间之后，能够得到释放。改进后<br>的代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class LockTest {</span><br><span class="line">public static void main(String[] args) {</span><br><span class="line">Redis redis = new Redis();</span><br><span class="line">redis.execute(jedis-&gt;{</span><br><span class="line">Long setnx = jedis.setnx("k1", "v1");</span><br><span class="line">if (setnx == 1) {</span><br><span class="line">//给锁添加一个过期时间，防止应用在运行过程中抛出异常导致锁无法及时得到释放</span><br><span class="line">jedis.expire("k1", 5);</span><br><span class="line">//没人占位</span><br><span class="line">jedis.set("name", "javaboy");</span><br><span class="line">String name = jedis.get("name");</span><br><span class="line">System.out.println(name);</span><br><span class="line">jedis.del("k1");//释放资源</span><br><span class="line">}else{</span><br><span class="line">//有人占位，停止/暂缓 操作</span><br><span class="line">}</span><br><span class="line">});</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这样改造之后，还有一个问题，就是在获取锁和设置过期时间之间如果如果服务器突然挂掉了，这个时<br>候锁被占用，无法及时得到释放，也会造成死锁，因为获取锁和设置过期时间是两个操作，不具备原子<br>性。<br>为了解决这个问题，从 Redis2.8 开始，setnx 和 expire 可以通过一个命令一起来执行了，我们对上述<br>代码再做改进：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class LockTest {</span><br><span class="line">public static void main(String[] args) {</span><br><span class="line">Redis redis = new Redis();</span><br><span class="line">redis.execute(jedis-&gt;{</span><br><span class="line">String set = jedis.set("k1", "v1", new SetParams().nx().ex(5));</span><br><span class="line">if (set !=null &amp;&amp; "OK".equals(set)) {</span><br><span class="line">//给锁添加一个过期时间，防止应用在运行过程中抛出异常导致锁无法及时得到释放</span><br><span class="line">jedis.expire("k1", 5);</span><br><span class="line">//没人占位</span><br><span class="line">jedis.set("name", "javaboy");</span><br><span class="line">String name = jedis.get("name");</span><br><span class="line">System.out.println(name);</span><br><span class="line">jedis.del("k1");//释放资源</span><br><span class="line">}else{</span><br><span class="line">//有人占位，停止/暂缓 操作</span><br><span class="line">}</span><br><span class="line">});</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="6-2-解决超时问题"><a href="#6-2-解决超时问题" class="headerlink" title="6.2 解决超时问题"></a>6.2 解决超时问题</h3><p>为了防止业务代码在执行的时候抛出异常，我们给每一个锁添加了一个超时时间，超时之后，锁会被自<br>动释放，但是这也带来了一个新的问题：如果要执行的业务非常耗时，可能会出现紊乱。举个例子：第<br>一个线程首先获取到锁，然后开始执行业务代码，但是业务代码比较耗时，执行了 8 秒，这样，会在第<br>一个线程的任务还未执行成功锁就会被释放了，此时第二个线程会获取到锁开始执行，在第二个线程刚<br>执行了 3 秒，第一个线程也执行完了，此时第一个线程会释放锁，但是注意，它释放的第二个线程的<br>锁，释放之后，第三个线程进来。<br>对于这个问题，我们可以从两个角度入手：<br>尽量避免在获取锁之后，执行耗时操作。<br>可以在锁上面做文章，将锁的 value 设置为一个随机字符串，每次释放锁的时候，都去比较随机<br>字符串是否一致，如果一致，再去释放，否则，不释放。<br>对于第二种方案，由于释放锁的时候，要去查看锁的 value，第二个比较 value 的值是否正确，第三步<br>释放锁，有三个步骤，很明显三个步骤不具备原子性，为了解决这个问题，我们得引入 Lua 脚本。<br>Lua 脚本的优势：<br>1.使用方便，Redis 中内置了对 Lua 脚本的支持。<br>2.Lua 脚本可以在 Redis 服务端原子的执行多个 Redis 命令。</p>
<p>3.由于网络在很大程度上会影响到 Redis 性能，而使用 Lua 脚本可以让多个命令一次执行，可以有<br>效解决网络给 Redis 带来的性能问题。</p>
<p>在 Redis 中，使用 Lua 脚本，大致上两种思路：</p>
<ol>
<li>提前在 Redis 服务端写好 Lua 脚本，然后在 Java 客户端去调用脚本（推荐）。</li>
<li>可以直接在 Java 端去写 Lua 脚本，写好之后，需要执行时，每次将脚本发送到 Redis 上去执行。</li>
</ol>
<p>首先在 Redis 服务端创建 Lua 脚本，内容如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if redis.call("get",KEYS[1])==ARGV[1] then</span><br><span class="line">return redis.call("del",KEYS[1])</span><br><span class="line">else</span><br><span class="line">return 0</span><br><span class="line">end</span><br></pre></td></tr></tbody></table></figure>

<p>接下来，可以给 Lua 脚本求一个 SHA1 和，命令如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat lua/releasewherevalueequal.lua | redis-cli -a javaboy script load --pipe</span><br></pre></td></tr></tbody></table></figure>

<p>script load 这个命令会在 Redis 服务器中缓存 Lua 脚本，并返回脚本内容的 SHA1 校验和，然后在<br>Java 端调用时，传入 SHA1 校验和作为参数，这样 Redis 服务端就知道执行哪个脚本了。</p>
<p>接下来，在 Java 端调用这个脚本。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LuaTest</span> </span>{</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">Redis redis = <span class="keyword">new</span> Redis();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) {</span><br><span class="line">redis.execute(jedis -&gt; {</span><br><span class="line"><span class="comment">//1.先获取一个随机字符串</span></span><br><span class="line">String value = UUID.randomUUID().toString();</span><br><span class="line"><span class="comment">//2.获取锁</span></span><br><span class="line">String k1 = jedis.set(<span class="string">"k1"</span>, value, <span class="keyword">new</span> SetParams().nx().ex(<span class="number">5</span>));</span><br><span class="line"><span class="comment">//3.判断是否成功拿到锁</span></span><br><span class="line"><span class="keyword">if</span> (k1 != <span class="keyword">null</span> &amp;&amp; <span class="string">"OK"</span>.equals(k1)) {</span><br><span class="line"><span class="comment">//4. 具体的业务操作</span></span><br><span class="line">jedis.set(<span class="string">"site"</span>, <span class="string">"www.javaboy.org"</span>);</span><br><span class="line">String site = jedis.get(<span class="string">"site"</span>);</span><br><span class="line">System.out.println(site);</span><br><span class="line"><span class="comment">//5.释放锁</span></span><br><span class="line">jedis.evalsha(<span class="string">"b8059ba43af6ffe8bed3db65bac35d452f8115d8"</span>,</span><br><span class="line">Arrays.asList(<span class="string">"k1"</span>), Arrays.asList(value));</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">System.out.println(<span class="string">"没拿到锁"</span>);</span><br><span class="line">}</span><br><span class="line">});</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat releasewherevalueequal.lua | redis-cli -a lunanboy script load --pipe</span><br><span class="line">-a后面是redis密码 根据实际情况填写</span><br></pre></td></tr></tbody></table></figure>

<h2 id="7-Redis-做消息队列"><a href="#7-Redis-做消息队列" class="headerlink" title="7.Redis 做消息队列"></a>7.Redis 做消息队列</h2><p>我们平时说到消息队列，一般都是指 RabbitMQ、RocketMQ、ActiveMQ 以及大数据里边的 Kafka，<br>这些是我们比较常见的消息中间件，也是非常专业的消息中间件，作为专业的中间件，它里边提供了许<br>多功能。<br>但是，当我们需要使用消息中间件的时候，并非每次都需要非常专业的消息中间件，假如我们只有一个<br>消息队列，只有一个消费者，那就没有必要去使用上面这些专业的消息中间件，这种情况我们可以直接<br>使用 Redis 来做消息队列。<br>Redis 的消息队列不是特别专业，他没有很多高级特性，适用简单的场景，如果对于消息可靠性有着极<br>高的追求，那么不适合使用 Redis 做消息队列。</p>
<h3 id="7-1-消息队列"><a href="#7-1-消息队列" class="headerlink" title="7.1 消息队列"></a>7.1 消息队列</h3><p>Redis 做消息队列，使用它里边的 List 数据结构就可以实现，我们可以使用 lpush/rpush 操作来实现入<br>队，然后使用 lpop/rpop 来实现出队。<br>回顾一下：<br>在客户端（例如 Java 端），我们会维护一个死循环来不停的从队列中读取消息，并处理，如果队列中<br>有消息，则直接获取到，如果没有消息，就会陷入死循环，直到下一次有消息进入，这种死循环会造成<br>大量的资源浪费，这个时候，我们可以使用之前讲的 blpop/brpop 。</p>
<h3 id="7-2-延迟消息队列"><a href="#7-2-延迟消息队列" class="headerlink" title="7.2 延迟消息队列"></a>7.2 延迟消息队列</h3><p>延迟队列可以通过 zset 来实现，因为 zset 中有一个 score，我们可以把时间作为 score，将 value 存到<br>redis 中，然后通过轮询的方式，去不断的读取消息出来。<br>首先，如果消息是一个字符串，直接发送即可，如果是一个对象，则需要对对象进行序列化，这里我们<br>使用 JSON 来实现序列化和反序列化。<br>所以，首先在项目中，添加 JSON 依赖：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;2.10.3&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>接下来，构造一个消息对象：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class JavaboyMessage {</span><br><span class="line">private String id;</span><br><span class="line">private Object data;</span><br><span class="line">@Override</span><br><span class="line">public String toString() {</span><br><span class="line">return "JavaboyMessage{" +</span><br><span class="line">"id='" + id + '\'' +</span><br><span class="line">", data=" + data +</span><br><span class="line">'}';</span><br><span class="line">}</span><br><span class="line">public String getId() {</span><br><span class="line">return id;</span><br><span class="line">}</span><br><span class="line">public void setId(String id) {</span><br><span class="line">this.id = id;</span><br><span class="line">}</span><br><span class="line">public Object getData() {</span><br><span class="line">return data;</span><br><span class="line">}</span><br><span class="line">public void setData(Object data) {</span><br><span class="line">this.data = data;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>接下来封装一个消息队列：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">public class DelayMsgQueue {</span><br><span class="line">private Jedis jedis;</span><br><span class="line">private String queue;</span><br><span class="line">public DelayMsgQueue(Jedis jedis, String queue) {</span><br><span class="line">this.jedis = jedis;</span><br><span class="line">this.queue = queue;</span><br><span class="line">}</span><br><span class="line">/**</span><br><span class="line">* 消息入队</span><br><span class="line">*</span><br><span class="line">* @param data 要发送的消息</span><br><span class="line">*/</span><br><span class="line">public void queue(Object data) {</span><br><span class="line">//构造一个 JavaboyMessage</span><br><span class="line">JavaboyMessage msg = new JavaboyMessage();</span><br><span class="line">msg.setId(UUID.randomUUID().toString());</span><br><span class="line">msg.setData(data);</span><br><span class="line">//序列化</span><br><span class="line">try {</span><br><span class="line">String s = new ObjectMapper().writeValueAsString(msg);</span><br><span class="line">System.out.println("msg publish:" + new Date());</span><br><span class="line">//消息发送，score 延迟 5 秒</span><br><span class="line">jedis.zadd(queue, System.currentTimeMillis() + 5000, s);</span><br><span class="line">} catch (JsonProcessingException e) {</span><br><span class="line">e.printStackTrace();</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">/**</span><br><span class="line">* 消息消费</span><br><span class="line">*/</span><br><span class="line">public void loop() {</span><br><span class="line">while (!Thread.interrupted()) {</span><br><span class="line">//读取 score 在 0 到当前时间戳之间的消息</span><br><span class="line">Set&lt;String&gt; zrange = jedis.zrangeByScore(queue, 0,</span><br><span class="line">System.currentTimeMillis(), 0, 1);</span><br><span class="line">if (zrange.isEmpty()) {</span><br><span class="line">//如果消息是空的，则休息 500 毫秒然后继续</span><br><span class="line">try {</span><br><span class="line">Thread.sleep(500);</span><br><span class="line">} catch (InterruptedException e) {</span><br><span class="line">break;</span><br><span class="line">}</span><br><span class="line">continue;</span><br><span class="line">}</span><br><span class="line">//如果读取到了消息，则直接读取消息出来</span><br><span class="line">String next = zrange.iterator().next();</span><br><span class="line">if (jedis.zrem(queue, next) &gt; 0) {</span><br><span class="line">//抢到了，接下来处理业务</span><br><span class="line">try {</span><br><span class="line">JavaboyMessage msg = new ObjectMapper().readValue(next,</span><br><span class="line">JavaboyMessage.class);</span><br><span class="line">System.out.println("receive msg:" + msg);</span><br><span class="line">} catch (JsonProcessingException e) {</span><br><span class="line">e.printStackTrace();</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>测试：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public class DelayMsgTest {</span><br><span class="line">public static void main(String[] args) {</span><br><span class="line">Redis redis = new Redis();</span><br><span class="line">redis.execute(jedis -&gt; {</span><br><span class="line">//构造一个消息队列</span><br><span class="line">DelayMsgQueue queue = new DelayMsgQueue(jedis, "javaboy-delayqueue");</span><br><span class="line">//构造消息生产者</span><br><span class="line">Thread producer = new Thread(){</span><br><span class="line">@Override</span><br><span class="line">public void run() {</span><br><span class="line">for (int i = 0; i &lt; 5; i++) {</span><br><span class="line">queue.queue("www.javaboy.org&gt;&gt;&gt;&gt;" + i);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">};</span><br><span class="line">//构造一个消息消费者</span><br><span class="line">Thread consumer = new Thread(){</span><br><span class="line">@Override</span><br><span class="line">public void run() {</span><br><span class="line">queue.loop();</span><br><span class="line">}</span><br><span class="line">};</span><br><span class="line">//启动</span><br><span class="line">producer.start();</span><br><span class="line">consumer.start();</span><br><span class="line">//休息 7 秒后，停止程序</span><br><span class="line">try {</span><br><span class="line">Thread.sleep(7000);</span><br><span class="line">consumer.interrupt();</span><br><span class="line">} catch (InterruptedException e) {</span><br><span class="line">e.printStackTrace();</span><br><span class="line">}</span><br><span class="line">});</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="8-再谈-Bit-操作"><a href="#8-再谈-Bit-操作" class="headerlink" title="8.再谈 Bit 操作"></a>8.再谈 Bit 操作</h2><h3 id="8-1-基本介绍"><a href="#8-1-基本介绍" class="headerlink" title="8.1 基本介绍"></a>8.1 基本介绍</h3><p>用户一年的签到记录，如果你用 string 类型来存储，那你需要 365 个 key/value，操作起来麻烦。通过<br>位图可以有效的简化这个操作。<br>它的统计很简单：<br>01111000111<br>每天的记录占一个位，365 天就是 365 个位，大概 46 个字节，这样可以有效的节省存储空间，如果有<br>一天想要统计用户一共签到了多少天，统计 1 的个数即可。<br>对于位图的操作，可以直接操作对应的字符串（get/set），可以直接操作位（getbit/setbit）.</p>
<h3 id="8-2-基本操作"><a href="#8-2-基本操作" class="headerlink" title="8.2 基本操作"></a>8.2 基本操作</h3><p>Redis 的基本操作可以归为两大类：</p>
<h4 id="8-2-1-零存整取"><a href="#8-2-1-零存整取" class="headerlink" title="8.2.1 零存整取"></a>8.2.1 零存整取</h4><p>例如存储一个 Java 字符串：</p>
<table>
<thead>
<tr>
<th align="center">字符</th>
<th>ASCII</th>
<th>二进制</th>
</tr>
</thead>
<tbody><tr>
<td align="center">J</td>
<td>74</td>
<td>01001010</td>
</tr>
<tr>
<td align="center">a</td>
<td>97</td>
<td>01100001</td>
</tr>
<tr>
<td align="center">v</td>
<td>118</td>
<td>01110110</td>
</tr>
</tbody></table>
<p>接下来去存储：</p>
<p><img src="https://gitee.com/penno/blogimg/raw/master/img/20210524003422.png" alt="image-20210524003422814"></p>
<h4 id="8-2-1-整存零取"><a href="#8-2-1-整存零取" class="headerlink" title="8.2.1 整存零取"></a>8.2.1 整存零取</h4><p>存一个字符串进去，但是通过位操作获取字符串。</p>
<h3 id="8-3-统计"><a href="#8-3-统计" class="headerlink" title="8.3 统计"></a>8.3 统计</h3><p>例如签到记录：<br>01111000111<br>1 表示签到的天，0 表示没签到，统计总的签到天数：<br>可以使用 bitcount。</p>
<p><img src="https://gitee.com/penno/blogimg/raw/master/img/20210524003506.png" alt="image-20210524003506621"></p>
<p>bitcount 中，可以统计的起始位置，但是注意，这个起始位置是指字符的起始位置而不是 bit 的起始位<br>置。<br>除了 bitcount 之外，还有一个 bitpos。bitpos 可以用来统计在指定范围内出现的第一个 1 或者 0 的位<br>置，这个命令中的起始和结束位置都是字符索引，不是 bit 索引，一定要注意。</p>
<h3 id="8-4-Bit-批处理"><a href="#8-4-Bit-批处理" class="headerlink" title="8.4 Bit 批处理"></a>8.4 Bit 批处理</h3><p>在 Redis 3.2 之后，新加了一个功能叫做 bitfiled ，可以对 bit 进行批量操作。<br>例如：<br>BITFIELD name get u4 0<br>表示获取 name 中的位，从 0 开始获取，获取 4 个位，返回一个无符号数字。<br>    u 表示无符号数字<br>    i 表示有符号数字，有符号的话，第一个符号就表示符号位，1 表示是一个负数。</p>
<p>bitfiled 也可以一次执行多个操作。</p>
<p>GET：</p>
<p><img src="https://gitee.com/penno/blogimg/raw/master/img/20210524003544.png" alt="image-20210524003544657"></p>
<p>SET：</p>
<p>用无符号的 98 转成的 8 位二进制数字，代替从第 8 位开始接下来的 8 位数字。</p>
<p><img src="https://gitee.com/penno/blogimg/raw/master/img/20210524003557.png" alt="image-20210524003557746"></p>
<p>INCRBY：</p>
<p>对置顶范围进行自增操作，自增操作可能会出现溢出，既可能是向上溢出，也可能是向下溢出。Redis<br>中对于溢出的处理方案是折返。8 位无符号数 255 加 1 溢出变为 0；8 位有符号数 127，加 1 变为 -<br>128.</p>
<p>也可以修改默认的溢出策略，可以改为 fail ，表示执行失败。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BITFIELD name overflow fail incrby u2 6 1</span><br></pre></td></tr></tbody></table></figure>

<p>sat 表示留在在最大/最小值。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BITFIELD name overflow sat incrby u2 6 1</span><br></pre></td></tr></tbody></table></figure>

<h2 id="9-HyperLogLog"><a href="#9-HyperLogLog" class="headerlink" title="9.HyperLogLog"></a>9.HyperLogLog</h2><p>一般我们评估一个网站的访问量，有几个主要的参数：<br>    pv，Page View，网页的浏览量<br>    uv，User View，访问的用户</p>
<p>一般来说，pv 或者 uv 的统计，可以自己来做，也可以借助一些第三方的工具，比如 cnzz，友盟 等。<br>如果自己实现，pv 比较简单，可以直接通过 Redis 计数器就能实现。但是 uv 就不一样，uv 涉及到另<br>外一个问题，去重。<br>我们首先需要在前端给每一个用户生成一个唯一 id，无论是登录用户还是未登录用户，都要有一个唯一<br>id，这个 id 伴随着请求一起到达后端，在后端我们通过 set 集合中的 sadd 命令来存储这个 id，最后通<br>过 scard 统计集合大小，进而得出 uv 数据。<br>如果是千万级别的 UV，需要的存储空间就非常惊人。而且，像 UV 统计这种，一般也不需要特别精<br>确，800w 的 uv 和 803w 的 uv，其实差别不大。所以，我们要介绍今天的主角—HyperLogLog<br>Redis 中提供的 HyperLogLog 就是专门用来解决这个问题的，HyperLogLog 提供了一套不怎么精确但<br>是够用的去重方案，会有误差，官方给出的误差数据是 0.81%，这个精确度，统计 UV 够用了。<br>HyperLogLog 主要提供了两个命令：pfadd 和 pfcount。<br>pfadd 用来添加记录，类似于 sadd ，添加过程中，重复的记录会自动去重。<br>pfcount 则用来统计数据。</p>
<p>数据量少的时候看不出来误差。<br>在 Java 中，我们多添加几个元素：    </p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class HyperLogLog {</span><br><span class="line">public static void main(String[] args) {</span><br><span class="line">Redis redis = new Redis();</span><br><span class="line">redis.execute(jedis -&gt; {</span><br><span class="line">for (int i = 0; i &lt; 1000; i++) {</span><br><span class="line">jedis.pfadd("uv", "u" + i, "u" + (i + 1));</span><br><span class="line">}</span><br><span class="line">long uv = jedis.pfcount("uv");</span><br><span class="line">System.out.println(uv);//理论值是 1001</span><br><span class="line">});</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>理论值是 1001，实际打印出来 994，有误差，但是在可以接受的范围内。<br>除了 pfadd 和 pfcount 之外，还有一个命令 pfmerge ，合并多个统计结果，在合并的过程中，会自动<br>去重多个集合中重复的元素。</p>
<h2 id="10-布隆过滤器"><a href="#10-布隆过滤器" class="headerlink" title="10.布隆过滤器"></a>10.布隆过滤器</h2><h3 id="10-1-场景重现"><a href="#10-1-场景重现" class="headerlink" title="10.1 场景重现"></a>10.1 场景重现</h3><p>我们用 HyperLogLog 来估计一个数，有偏差但是也够用。HyperLogLog 主要提供两个方法：<br>pfadd<br>pfcount<br>但是 HyperLogLog 没有判断是否包含的方法，例如 pfexists 、pfcontains 等。没有这样的方法存在，<br>但是我们有这样的业务需求。<br>例如刷今日头条，推送的内容有相似的，但是没有重复的。这就涉及到如何在推送的时候去重？<br>解决方案很多，例如将用户的浏览历史记录下来，然后每次推送时去比较该条消息是否已经给用户推送<br>了。但是这种方式效率极低，不推荐。<br>解决这个问题，就要靠我们今天要说的布隆过滤器。</p>
<h3 id="10-2-Bloom-Filter-介绍"><a href="#10-2-Bloom-Filter-介绍" class="headerlink" title="10.2 Bloom Filter 介绍"></a>10.2 Bloom Filter 介绍</h3><p>Bloom Filter 专门用来解决我们上面所说的去重问题的，使用 Bloom Filter 不会像使用缓存那么浪费空<br>间。当然，他也存在一个小小问题，就是不太精确。<br>Bloom Filter 相当于是一个不太精确的 set 集合，我们可以利用它里边的 contains 方法去判断某一个对<br>象是否存在，但是需要注意，这个判断不是特别精确。一般来说，通过 contains 判断某个值不存在，<br>那就一定不存在，但是判断某个值存在的话，则他可能不存在。</p>
<p>以今日头条为例，假设我们将用户的浏览记录用 B 表示，A 表示用户没有浏览的新闻，现在要给用户推<br>送消息，先去 B 里边判断这条消息是否已经推送过，如果判断结果说没推送过（B 里边没有这条记<br>录），那就一定没有推送过。如果判断结果说有推送过（B 里边也有可能没有这条消息），这个时候该<br>条消息就不会推送给用户，导致用户错过该条消息，当然这是概率极低的。</p>
<h3 id="10-3-Bloom-Filter-原理"><a href="#10-3-Bloom-Filter-原理" class="headerlink" title="10.3 Bloom Filter 原理"></a>10.3 Bloom Filter 原理</h3><p>每一个布隆过滤器，在 Redis 中都对应了一个大型的位数组以及几个不同的 hash 函数。</p>
<p>所谓的 add 操作是这样的：<br>首先根据几个不同的 hash 函数给元素进行 hash 运算一个整数索引值，拿到这个索引值之后，对位数<br>组的长度进行取模运算，得到一个位置，每一个 hash 函数都会得到一个位置，将位数组中对应的位置<br>设置位 1 ，这样就完成了添加操作。</p>
<p><img src="https://gitee.com/penno/blogimg/raw/master/img/20210525180124.png" alt="image-20210525180124216"></p>
<p>当判断元素是否粗存在时，依然先对元素进行 hash 运算，将运算的结果和位数组取模，然后去对应的<br>位置查看是否有相应的数据，如果有，表示元素可能存在（因为这个有数据的地方也可能是其他元素存<br>进来的），如果没有表示元素一定不存在。<br>Bloom Filter 中，误判的概率和位数组的大小有很大关系，位数组越大，误判概率越小，当然占用的存<br>储空间越大；位数组越小，误判概率越大，当然占用的存储空间就小。</p>
<h3 id="10-4-Bloom-Filter-安装"><a href="#10-4-Bloom-Filter-安装" class="headerlink" title="10.4 Bloom Filter 安装"></a>10.4 Bloom Filter 安装</h3><p><a target="_blank" rel="noopener" href="https://oss.redislabs.com/redisbloom/Quick_Start/">https://oss.redislabs.com/redisbloom/Quick_Start/</a></p>
<p>这里给大家介绍两种安装方式：</p>
<ol>
<li>Docker：</li>
</ol>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 6379:6379 --name redis-redisbloom redislabs/rebloom:latest</span><br></pre></td></tr></tbody></table></figure>

<ol start="2">
<li>自己编译安装：</li>
</ol>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd redis-5.0.7</span><br><span class="line">git clone https://github.com/RedisBloom/RedisBloom.git</span><br><span class="line">cd RedisBloom/</span><br><span class="line">make</span><br><span class="line">cd ..</span><br><span class="line">redis-server redis.conf --loadmodule ./RedisBloom/redisbloom.so</span><br></pre></td></tr></tbody></table></figure>

<p>安装完成后，执行 bf.add 命令，测试安装是否成功。<br>每次启动时都输入 <code>redis-server redis.conf --loadmodule ./RedisBloom/redisbloom.so</code> 比较<br>麻烦，我们可以将要加载的模块在 redis.conf 中提前配置好。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">################################## MODULES #####################################</span><br><span class="line"># Load modules at startup. If the server is not able to load modules</span><br><span class="line"># it will abort. It is possible to use multiple loadmodule directives.</span><br><span class="line">#</span><br><span class="line"># loadmodule /path/to/my_module.so</span><br><span class="line"># loadmodule /path/to/other_module.so</span><br><span class="line">loadmodule /root/redis-5.0.7/RedisBloom/redisbloom.so</span><br></pre></td></tr></tbody></table></figure>

<p>最下面这一句，配置完成后，以后只需要 redis-server redis.conf 来启动 Redis 即可。</p>
<h3 id="10-5-基本用法"><a href="#10-5-基本用法" class="headerlink" title="10.5 基本用法"></a>10.5 基本用法</h3><p>主要是两类命令，添加和判断是否存在。<br>bf.add\bf.madd 添加和批量添加<br>bf.exists\bf.mexists 判断是否存在和批量判断</p>
<p>使用 Jedis 操作布隆过滤器，首先添加依赖：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;com.redislabs&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;jrebloom&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;1.2.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>然后进行测试：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class BloomFilter {</span><br><span class="line">public static void main(String[] args) {</span><br><span class="line">GenericObjectPoolConfig config = new GenericObjectPoolConfig();</span><br><span class="line">config.setMaxIdle(300);</span><br><span class="line">config.setMaxTotal(1000);</span><br><span class="line">config.setMaxWaitMillis(30000);</span><br><span class="line">config.setTestOnBorrow(true);</span><br><span class="line">JedisPool pool = new JedisPool(config, "192.168.91.128", 6379, 30000,</span><br><span class="line">"javaboy");</span><br><span class="line">Client client = new Client(pool);</span><br><span class="line">//存入数据</span><br><span class="line">for (int i = 0; i &lt; 100000; i++) {</span><br><span class="line">client.add("name", "javaboy-" + i);</span><br><span class="line">}</span><br><span class="line">//检查数据是否存在</span><br><span class="line">boolean exists = client.exists("name", "javaboy-9999999");</span><br><span class="line">System.out.println(exists);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>默认情况下，我们使用的布隆过滤器它的错误率是 0.01 ，默认的元素大小是 100。但是这两个参数也<br>是可以配置的。<br>我们可以调用 bf.reserve 方法进行配置。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BF.RESERVE k1 0.0001 1000000</span><br></pre></td></tr></tbody></table></figure>

<p>第一个参数是 key，第二个参数是错误率，错误率越低，占用的空间越大，第三个参数预计存储的数<br>量，当实际数量超出预计数量时，错误率会上升。</p>
<h3 id="10-6-典型场景"><a href="#10-6-典型场景" class="headerlink" title="10.6 典型场景"></a>10.6 典型场景</h3><p>前面所说的新闻推送过滤算是一个应用场景。<br>解决 Redis 穿透或者又叫缓存击穿问题。<br>假设我有 1亿 条用户数据，现在查询用户要去数据库中查，效率低而且数据库压力大，所以我们会把请<br>求首先在 Redis 中处理（活跃用户存在 Redis 中），Redis 中没有的用户，再去数据库中查询。<br>现在可能会存在一种恶意请求，这个请求携带上了很多不存在的用户，这个时候 Redis 无法拦截下来请<br>求，所以请求会直接跑到数据库里去。这个时候，这些恶意请求会击穿我们的缓存，甚至数据库，进而<br>引起“雪崩效应”。<br>为了解决这个问题，我们就可以使用布隆过滤器。将 1亿条用户数据存在 Redis 中不现实，但是可以存<br>在布隆过滤器中，请求来了，首先去判断数据是否存在，如果存在，再去数据库中查询，否则就不去数<br>据库中查询。</p>
<h2 id="11-Redis-限流"><a href="#11-Redis-限流" class="headerlink" title="11.Redis 限流"></a>11.Redis 限流</h2><h3 id="11-1-预备知识"><a href="#11-1-预备知识" class="headerlink" title="11.1 预备知识"></a>11.1 预备知识</h3><p>Pipeline（管道）本质上是由客户端提供的一种操作。Pipeline 通过调整指令列表的读写顺序，可以大<br>幅度的节省 IO 时间，提高效率。</p>
<h3 id="11-2-简单限流"><a href="#11-2-简单限流" class="headerlink" title="11.2 简单限流"></a>11.2 简单限流</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">public class RateLimiter {</span><br><span class="line">private Jedis jedis;</span><br><span class="line">public RateLimiter(Jedis jedis) {</span><br><span class="line">this.jedis = jedis;</span><br><span class="line">}</span><br><span class="line">/**</span><br><span class="line">* 限流方法</span><br><span class="line">* @param user 操作的用户，相当于是限流的对象</span><br><span class="line">* @param action 具体的操作</span><br><span class="line">* @param period 时间窗，限流的周期</span><br><span class="line">* @param maxCount 限流的次数</span><br><span class="line">* @return</span><br><span class="line">*/</span><br><span class="line">public boolean isAllowed(String user, String action, int period, int</span><br><span class="line">maxCount) {</span><br><span class="line">//1.数据用 zset 保存，首先生成一个 key</span><br><span class="line">String key = user + "-" + action;</span><br><span class="line">//2.获取当前时间戳</span><br><span class="line">long nowTime = System.currentTimeMillis();</span><br><span class="line">//3.建立管道</span><br><span class="line">Pipeline pipelined = jedis.pipelined();</span><br><span class="line">pipelined.multi();</span><br><span class="line">//4.将当前的操作先存储下来</span><br><span class="line">pipelined.zadd(key, nowTime, String.valueOf(nowTime));</span><br><span class="line">//5.移除时间窗之外的数据</span><br><span class="line">pipelined.zremrangeByScore(key, 0, nowTime - period * 1000);</span><br><span class="line">//6.统计剩下的 key</span><br><span class="line">Response&lt;Long&gt; response = pipelined.zcard(key);</span><br><span class="line">//7.将当前 key 设置一个过期时间，过期时间就是时间窗</span><br><span class="line">pipelined.expire(key, period + 1);</span><br><span class="line">//关闭管道</span><br><span class="line">pipelined.exec();</span><br><span class="line">pipelined.close();</span><br><span class="line">//8.比较时间窗内的操作数</span><br><span class="line">return response.get() &lt;= maxCount;</span><br><span class="line">}</span><br><span class="line">public static void main(String[] args) {</span><br><span class="line">Redis redis = new Redis();</span><br><span class="line">redis.execute(j -&gt; {</span><br><span class="line">RateLimiter rateLimiter = new RateLimiter(j);</span><br><span class="line">for (int i = 0; i &lt; 20; i++) {</span><br><span class="line">System.out.println(rateLimiter.isAllowed("javaboy", "publish",</span><br><span class="line">5, 3));</span><br><span class="line">}</span><br><span class="line">});</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="11-3-深入限流操作"><a href="#11-3-深入限流操作" class="headerlink" title="11.3 深入限流操作"></a>11.3 深入限流操作</h3><p>Redis4.0 开始提供了一个 Redis-Cell 模块，这个模块使用漏斗算法，提供了一个非常好用的限流指令。<br>漏斗算法就像名字一样，是一个漏斗，请求从漏斗的大口进，然后从小口出进入到系统中，这样，无论<br>是多大的访问量，最终进入到系统中的请求，都是固定的。<br>使用漏斗算法，需要我们首先安装 Redis-Cell 模块：<br><a target="_blank" rel="noopener" href="https://github.com/brandur/redis-cell">https://github.com/brandur/redis-cell</a><br>安装步骤：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/brandur/redis-cell/releases/download/v0.2.4/redis-cellv0.2.4-</span><br><span class="line">x86_64-unknown-linux-gnu.tar.gz</span><br><span class="line">tar -zxvf redis-cell-v0.2.4-x86_64-unknown-linux-gnu.tar.gz</span><br><span class="line">mkdir redis-cell</span><br><span class="line">mv libredis_cell.d ./redis-cell</span><br><span class="line">mv libredis_cell.so ./redis-cell</span><br></pre></td></tr></tbody></table></figure>

<p>接下来修改 redis.conf 文件，加载额外的模块：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loadmodule /root/redis-5.0.7/redis-cell/libredis_cell.so</span><br></pre></td></tr></tbody></table></figure>

<p>然后，启动 Redis：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server redis.conf</span><br></pre></td></tr></tbody></table></figure>

<h5 id="Redis-中加入-Redis-Cell-模块，配置文件出错-version-GLIBC-2-18-not-found"><a href="#Redis-中加入-Redis-Cell-模块，配置文件出错-version-GLIBC-2-18-not-found" class="headerlink" title="Redis 中加入 Redis-Cell 模块，配置文件出错 version GLIBC_2.18 not found"></a>Redis 中加入 Redis-Cell 模块，配置文件出错 version <code>GLIBC_2.18</code> not found</h5><p>添加 Redis-Cell 模块到 redis.conf 配置文件中，启动就会报下面的错误。</p>
<p>最后配置了 redis.log 的日志发现是缺少 CLIBC_2.18 这个文件，经过一系列下载就解决了这个问题。</p>
<p>参考链接 ： <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_43647359/article/details/105864565">https://blog.csdn.net/qq_43647359/article/details/105864565</a></p>
<ol>
<li>下载 glibc 文件</li>
</ol>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 下载 glibc 压缩包</span><br><span class="line">wget http://ftp.gnu.org/gnu/glibc/glibc-2.18.tar.gz </span><br><span class="line">// 解压 glibc 压缩包</span><br><span class="line">tar -zxvf glibc-2.18.tar.gz</span><br><span class="line">// 进入解压后的目录</span><br><span class="line">cd glibc-2.18</span><br><span class="line">// 创建编译目录</span><br><span class="line">mkdir build</span><br><span class="line">// 进入到创建好的目录</span><br><span class="line">cd build/</span><br><span class="line">// 编译、安装</span><br><span class="line">../configure --prefix=/usr --disable-profile --enable-add-ons --with-headers=/usr/include --with-binutils=/usr/bin</span><br><span class="line"></span><br><span class="line">// 这一步比较慢</span><br><span class="line">make -j 8</span><br><span class="line"></span><br><span class="line">make install</span><br></pre></td></tr></tbody></table></figure>

<p>redis 启动成功后，如果存在 CL.THROTTLE 命令，说明 redis-cell 已经安装成功了。</p>
<p>CL.THROTTLE 命令一共有五个参数</p>
<ol>
<li>第一个参数是 key</li>
<li>第二个参数是漏斗的容量</li>
<li>时间窗内可以操作的次数</li>
<li>时间窗</li>
<li>每次漏出数量</li>
</ol>
<p>执行完成后，返回值也有五个：</p>
<ol>
<li>第一个 0 表示允许，1表示拒绝</li>
<li>第二个参数是漏斗的容量</li>
<li>第三个参数是漏斗的剩余空间</li>
<li>如果拒绝了，多长时间后，可以再试</li>
<li>多长时间后，漏斗会完全空出来</li>
</ol>
<h3 id="11-4-Lettuce扩展"><a href="#11-4-Lettuce扩展" class="headerlink" title="11.4 Lettuce扩展"></a>11.4 Lettuce扩展</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cl.throttle &lt;key&gt; &lt;max_burst&gt; &lt;count per period&gt; &lt;period&gt; [&lt;quantity&gt;]</span><br></pre></td></tr></tbody></table></figure>

<p>首先定义一个命令接口：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface RedisCommandInterface extends Commands {</span><br><span class="line">@Command("CL.THROTTLE ?0 ?1 ?2 ?3 ?4")</span><br><span class="line">List&lt;Object&gt; throttle(String key, Long init, Long count, Long period, Long</span><br><span class="line">quota);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>定义完成后，接下来，直接调用即可：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class ThrottleTest {</span><br><span class="line">public static void main(String[] args) {</span><br><span class="line">RedisClient redisClient =</span><br><span class="line">RedisClient.create("redis://javaboy@192.168.91.128");</span><br><span class="line">StatefulRedisConnection&lt;String, String&gt; connect = redisClient.connect();</span><br><span class="line">RedisCommandFactory factory = new RedisCommandFactory(connect);</span><br><span class="line">RedisCommandInterface commands =</span><br><span class="line">factory.getCommands(RedisCommandInterface.class);</span><br><span class="line">List&lt;Object&gt; list = commands.throttle("javaboy-publish", 10L, 10L, 60L,</span><br><span class="line">1L);</span><br><span class="line">System.out.println(list);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="12-Redis-之-Geo"><a href="#12-Redis-之-Geo" class="headerlink" title="12.Redis 之 Geo"></a>12.Redis 之 Geo</h2><p>Redis3.2 开始提供了 GEO 模块。该模块也使用了 GeoHash 算法。</p>
<h3 id="1-GeoHash"><a href="#1-GeoHash" class="headerlink" title="1.GeoHash"></a>1.GeoHash</h3><p>核心思想：GeoHash 是一种地址编码方法，使用这种方式，能够将二维的空间经纬度数据编码成一个<br>一维字符串。<br>地球上经纬度的划分：</p>
<p>以经过伦敦格林尼治天文台旧址的经线为 0 度经线，向东就是东经，向西就是西经。如果我们将西经定<br>义负，经度的范围就是 [-180,180]。<br>纬度北纬 90 度到南纬 90 度，如果我们将南纬定义负，则纬度的范围就是 [-90,90]。<br>接下来，以本初子午线和赤道为界，我们可以将地球上的点分配到一个二维坐标中：</p>
<p><img src="https://gitee.com/penno/blogimg/raw/master/img/20210526010744.png" alt="image-20210526010744884"></p>
<p>GeoHash 算法就是基于这样的思想，划分的次数越多，区域越多，每个区域中的面积就更小了，精确<br>度就会提高。<br>GeoHash 具体算法：<br>以北京天安门广场为例（39.9053908600,116.3980007200）：</p>
<ol>
<li>纬度的范围在 (-90,90) 之间，中间值为 0，对于 39.9053908600 值落在 (0,90),因此得到的值为 1</li>
<li>(0,90) 的中间值为 45，39.9053908600 落在 (0,45) 之间，因此得到一个 0</li>
<li>(0,45) 的中间值为 22.5，39.9053908600 落在 (22.5,45)之间，因此得到一个 1</li>
<li>….</li>
</ol>
<p>这样，我们得到的纬度二进制是 101<br>按照同样的步骤，我们可以算出来经度的二进制是 110<br>接下来将经纬度合并（经度占偶数位，纬度占奇数位）：<br>111001<br>按照 Base32 （0-9,b-z,去掉 a i l 0）对合并后的二进制数据进行编码，编码的时候，先将二进制转换为<br>十进制，然后进行编码。</p>
<p>将编码得到的字符串，可以拿去 geohash.org 网站上解析。<br>GeoHash 有哪些特点：</p>
<ol>
<li>用一个字符串表示经纬度</li>
<li>GeoHash 表示的是一个区域，而不是一个点。</li>
<li>编码格式有规律，例如一个地址编码之后的格式是 123，另一个地址编码之后的格式是 123456，<br>从字符串上就可以看出来，123456 处于 123 之中。</li>
</ol>
<h3 id="Redis-中使用"><a href="#Redis-中使用" class="headerlink" title="Redis 中使用"></a>Redis 中使用</h3><p>添加地址：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GEOADD city 116.3980007200 39.9053908600 beijing</span><br><span class="line">GEOADD city 114.0592002900 22.5536230800 shenzhen</span><br></pre></td></tr></tbody></table></figure>

<p>查看两个地址之间的距离：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; GEODIST city beijing shenzhen km</span><br><span class="line">"1942.5435"</span><br></pre></td></tr></tbody></table></figure>

<p>获取元素的位置：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; GEOPOS city beijing</span><br><span class="line">1) 1) "116.39800339937210083"</span><br><span class="line">	2) "39.90539144357683909"</span><br></pre></td></tr></tbody></table></figure>

<p>获取元素 hash 值：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; GEOHASH city beijing</span><br><span class="line">1) "wx4g08w3y00"</span><br></pre></td></tr></tbody></table></figure>

<p>通过 hash 值可以查看定位。<a target="_blank" rel="noopener" href="http://geohash.org/wx4g08w3y00">http://geohash.org/wx4g08w3y00</a><br>查看附近的人：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; GEORADIUSBYMEMBER city beijing 200 km count 3 asc</span><br><span class="line">1) "beijing"</span><br></pre></td></tr></tbody></table></figure>

<p>以北京为中心，方圆 200km 以内的城市找出来 3 个，按照远近顺序排列，这个命令不会排除 北京。<br>当然，也可以根据经纬度来查询（将 member 换成对应的经纬度）：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; GEORADIUS city 116.3980007200 39.9053908600 2000 km withdist</span><br><span class="line">withhash withcoord count 4 desc</span><br></pre></td></tr></tbody></table></figure>

<p><a target="_blank" rel="noopener" href="http://www.gpsspg.com/maps.htm">http://www.gpsspg.com/maps.htm</a></p>
<h2 id="13-Redis-之-Scan"><a href="#13-Redis-之-Scan" class="headerlink" title="13.Redis 之 Scan"></a>13.Redis 之 Scan</h2><h3 id="1-简单介绍"><a href="#1-简单介绍" class="headerlink" title="1.简单介绍"></a>1.简单介绍</h3><p>scan 实际上是 keys 的一个升级版。<br>可以用 keys 来查询 key，在查询的过程中，可以使用通配符。keys 虽然用着还算方便，但是没有分页<br>功能。同时因为 Redis 是单线程，所以 key 的执行会比较消耗时间，特别是当数据量大的时候，影响整<br>个程序的运行。<br>为了解决 keys 存在的问题，从 Redis2.8 中开始，引入了 scan。<br>scan 具备 keys 的功能，但是不会阻塞线程，而且可以控制每次返回的结果数。</p>
<h3 id="2-基本用法"><a href="#2-基本用法" class="headerlink" title="2.基本用法"></a>2.基本用法</h3><p>首先准备 10000 条测试数据：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScanTest</span> </span>{</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">Redis redis = <span class="keyword">new</span> Redis();</span><br><span class="line">redis.execute(jedis -&gt; {</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) {</span><br><span class="line">jedis.set(<span class="string">"k"</span> + i, <span class="string">"v"</span> + i);</span><br><span class="line">}</span><br><span class="line">});</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>scan 命令一共提供了三个参数，第一个 cursor，第二个参数是 key，第三个参数是 limit。<br>cursor 实际上是指一维数组的位置索引，limit 则是遍历的一维数组个数（所以每次返回的数据大小可<br>能不确定）。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scan 0 match k8* count 1000</span><br></pre></td></tr></tbody></table></figure>

<h3 id="3-原理"><a href="#3-原理" class="headerlink" title="3.原理"></a>3.原理</h3><p>SCAN 的遍历顺序。<br>假设目有三条数据：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) "key1"</span><br><span class="line">2) "db_number"</span><br><span class="line">3) "myKey"</span><br><span class="line">127.0.0.1:6379&gt; scan 0 match * count 1</span><br><span class="line">1) "2"</span><br><span class="line">2) 1) "key1"</span><br><span class="line">127.0.0.1:6379&gt; scan 2 match * count 1</span><br><span class="line">1) "1"</span><br><span class="line">2) 1) "myKey"</span><br><span class="line">127.0.0.1:6379&gt; scan 1 match * count 1</span><br><span class="line">1) "3"</span><br><span class="line">2) 1) "db_number"</span><br><span class="line">127.0.0.1:6379&gt; scan 3 match * count 1</span><br><span class="line">1) "0"</span><br><span class="line">2) (empty list or set)</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>在遍历的过程中，大家发现游标的顺序是 0 2 1 3，从十进制来看好像没有规律，但是从转为二进制，<br>则是有规律的：</p>
<p><code>00-&gt;10-&gt;01-&gt;11</code></p>
<p>这种规律就是高位进1，传统的二进制加法，是从右往左加，这里是从左往右加。<br>实际上，在 Redis 中，它的具体计算流程给是这样：</p>
<ol>
<li>将要计算的数字反转</li>
<li>给反转后的数字加 1</li>
<li>再反转</li>
</ol>
<p>那么为什么不是按照 0、1、2、3、4…这样的顺序遍历呢？因为主要考虑到两个问题：</p>
<ol>
<li>字典扩容</li>
<li>字典缩容</li>
</ol>
<p><img src="https://gitee.com/penno/blogimg/raw/master/img/20210526165224.png" alt="image-20210526165224745"></p>
<p>假如我们将要访问 110 时，发生了扩容，此时 scan 就会从 0110 开始遍历，之前已经被遍历过的元素<br>就不会被重复遍历了。<br>假如我们将要访问 110 时，发生缩容，此时 scan 就会从 10 开始遍历，这个时候，也会遍历到 010，<br>但是 010 之前的不会再被遍历了。所以，在发生缩容的时候，可能返回重复的元素。</p>
<h3 id="4-其他用法"><a href="#4-其他用法" class="headerlink" title="4.其他用法"></a>4.其他用法</h3><p>scan 是一系列的指令，除了遍历所有的 key 之外，也可以遍历某一个类型的 key，对应的命令有：<br>zscan–&gt;zset<br>hscan–&gt;hash<br>sscan–&gt;set</p>
<h2 id="14-Redis-单线程如何处理高并发"><a href="#14-Redis-单线程如何处理高并发" class="headerlink" title="14.Redis 单线程如何处理高并发"></a>14.Redis 单线程如何处理高并发</h2><h3 id="1-阻塞-IO-与非阻塞-IO"><a href="#1-阻塞-IO-与非阻塞-IO" class="headerlink" title="1.阻塞 IO 与非阻塞 IO"></a>1.阻塞 IO 与非阻塞 IO</h3><p>Java 在 JDK1.4 中引入 NIO，但是也有很多人在使用阻塞 IO，这两种 IO 有什么区别？<br>在阻塞模式下，如果你从数据流中读取不到指定大小的数据两，IO 就会阻塞。比如已知会有 10 个字节<br>发送过来，但是我目前只收到 4 个，还剩六个，此时就会发生阻塞。如果是非阻塞模式，虽然此时只收<br>到 4 个字节，但是读到 4 个字节就会立即返回，不会傻傻等着，等另外 6 个字节来的时候，再去继续读<br>取。<br>所以阻塞 IO 性能低于 非阻塞 IO。<br>如果有一个 Web 服务器，使用阻塞 IO 来处理请求，那么每一个请求都需要开启一个新的线程；但是如<br>果使用了非阻塞 IO，基本上一个小小线程池就够用了，因为不会发生阻塞，每一个线程都能够高效利<br>用。</p>
<p>Java 在 JDK1.4 中引入 NIO，但是也有很多人在使用阻塞 IO，这两种 IO 有什么区别？<br>在阻塞模式下，如果你从数据流中读取不到指定大小的数据两，IO 就会阻塞。比如已知会有 10 个字节<br>发送过来，但是我目前只收到 4 个，还剩六个，此时就会发生阻塞。如果是非阻塞模式，虽然此时只收<br>到 4 个字节，但是读到 4 个字节就会立即返回，不会傻傻等着，等另外 6 个字节来的时候，再去继续读<br>取。<br>所以阻塞 IO 性能低于 非阻塞 IO。<br>如果有一个 Web 服务器，使用阻塞 IO 来处理请求，那么每一个请求都需要开启一个新的线程；但是如<br>果使用了非阻塞 IO，基本上一个小小线程池就够用了，因为不会发生阻塞，每一个线程都能够高效利<br>用。</p>
<h3 id="2-Redis-的线程模型"><a href="#2-Redis-的线程模型" class="headerlink" title="2.Redis 的线程模型"></a>2.Redis 的线程模型</h3><p>首先一点，Redis 是单线程。单线程如何解决高并发问题的？<br>实际上，能够处理高并发的单线程应用不仅仅是 Redis，除了 Redis 之外，还有 NodeJS、Nginx 等等<br>也是单线程。</p>
<p>Redis 虽然是单线程，但是运行很快，主要有如下几方面原因：</p>
<ol>
<li>Redis 中的所有数据都是基于内存的，所有的计算也都是内存级别的计算，所以快。</li>
<li>Redis 是单线程的，所以有一些时间复杂度高的指令，可能会导致 Redis 卡顿，例如 keys。</li>
<li>Redis 在处理并发的客户端连接时，使用了非阻塞 IO。</li>
</ol>
<p>在使用非阻塞 IO 时，有一个问题，就是线程如何知道剩下的数据来了？<br>这里就涉及到一个新的概念叫做多路复用，本质上就是一个事件轮询 API。</p>
<ol start="4">
<li>Redis 会给每一个客户端指令通过队列来排队进行顺序处理。</li>
<li>Redis 做出响应时，也会有一个响应的队列。</li>
</ol>
<h2 id="15-Redis-通信协议"><a href="#15-Redis-通信协议" class="headerlink" title="15.Redis 通信协议"></a>15.Redis 通信协议</h2><p>Redis 通信使用了文本协议，文本协议比较费流量，但是 Redis 作者认为数据库的瓶颈不在于网络流<br>量，而在于内部逻辑，所以采用了这样一个费流量的文本协议。<br>这个文本协议叫做 Redis Serialization Protocol，简称 RESP。<br>Redis 协议将传输的数据结构分为 5 种最小单元，单元结束时，加上回车换行符 \r\n。</p>
<ol>
<li>单行字符串以 + 开始，例如 +javaboy.org\r\n</li>
<li>多行字符串以 $ 开始，后面加上字符串长度，例如 $11\r\njavaboy.org\r\n</li>
<li>整数值以: 开始，例如 :1024\r\n</li>
<li>错误消息以 - 开始</li>
<li>数组以 * 开始，后面加上数组长度。<br>需要注意的是，如果是客户端连接服务端，只能使用第 5 种。</li>
</ol>
<h3 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1.准备工作"></a>1.准备工作</h3><p>做两件事情：<br>为了方便客户端连接 Redis，我们关闭 Redis 种的保护模式(在 redis.conf 文件中)<br>protected no<br>同时关闭密码</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># requirepass xxxx</span><br></pre></td></tr></tbody></table></figure>

<p>配置完成后，重启 Redis。</p>
<h3 id="2-实战"><a href="#2-实战" class="headerlink" title="2. 实战"></a>2. 实战</h3><p>接下来，我们通过 Socket+RESP 来定义两个最最常见的命令 set 和 get。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaboyRedisClient</span> </span>{</span><br><span class="line"><span class="keyword">private</span> Socket socket;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">JavaboyRedisClient</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">socket = <span class="keyword">new</span> Socket(<span class="string">"192.168.91.128"</span>, <span class="number">6379</span>);</span><br><span class="line">} <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">e.printStackTrace();</span><br><span class="line">System.out.println(<span class="string">"Redis 连接失败"</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 执行 Redis 中的 set 命令 [set,key,value]</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">set</span><span class="params">(String key, String value)</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">sb.append(<span class="string">"*3"</span>)</span><br><span class="line">.append(<span class="string">"\r\n"</span>)</span><br><span class="line">.append(<span class="string">"$"</span>)</span><br><span class="line">.append(<span class="string">"set"</span>.length())</span><br><span class="line">.append(<span class="string">"\r\n"</span>)</span><br><span class="line">.append(<span class="string">"set"</span>)</span><br><span class="line">.append(<span class="string">"\r\n"</span>)</span><br><span class="line">.append(<span class="string">"$"</span>)</span><br><span class="line">.append(key.getBytes().length)</span><br><span class="line">.append(<span class="string">"\r\n"</span>)</span><br><span class="line">.append(key)</span><br><span class="line">.append(<span class="string">"\r\n"</span>)</span><br><span class="line">.append(<span class="string">"$"</span>)</span><br><span class="line">.append(value.getBytes().length)</span><br><span class="line">.append(<span class="string">"\r\n"</span>)</span><br><span class="line">.append(value)</span><br><span class="line">.append(<span class="string">"\r\n"</span>);</span><br><span class="line">System.out.println(sb.toString());</span><br><span class="line">socket.getOutputStream().write(sb.toString().getBytes());</span><br><span class="line"><span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">socket.getInputStream().read(buf);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> String(buf);</span><br><span class="line">}</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 执行 Redis 中的 get 命令 [get,key]</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(String key)</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">sb.append(<span class="string">"*2"</span>)</span><br><span class="line">.append(<span class="string">"\r\n"</span>)</span><br><span class="line">.append(<span class="string">"$"</span>)</span><br><span class="line">.append(<span class="string">"get"</span>.length())</span><br><span class="line">.append(<span class="string">"\r\n"</span>)</span><br><span class="line">.append(<span class="string">"get"</span>)</span><br><span class="line">.append(<span class="string">"\r\n"</span>)</span><br><span class="line">.append(<span class="string">"$"</span>)</span><br><span class="line">.append(key.getBytes().length)</span><br><span class="line">.append(<span class="string">"\r\n"</span>)</span><br><span class="line">.append(key)</span><br><span class="line">.append(<span class="string">"\r\n"</span>);</span><br><span class="line">socket.getOutputStream().write(sb.toString().getBytes());</span><br><span class="line"><span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">socket.getInputStream().read(buf);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> String(buf);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">String set = <span class="keyword">new</span> JavaboyRedisClient().set(<span class="string">"k1"</span>, <span class="string">"江南一点雨"</span>);</span><br><span class="line">System.out.println(set);</span><br><span class="line">String k1 = <span class="keyword">new</span> JavaboyRedisClient().get(<span class="string">"k1"</span>);</span><br><span class="line">System.out.println(k1);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="16-Redis-持久化"><a href="#16-Redis-持久化" class="headerlink" title="16.Redis 持久化"></a>16.Redis 持久化</h2><p>Redis 是一个缓存工具，也叫做 NoSQL 数据库，既然是数据库，必然支持数据的持久化操作。在 Redis<br>中，数据库持久化一共有两种方案：</p>
<ol>
<li>快照方式</li>
<li>AOF 日志</li>
</ol>
<h3 id="1-快照"><a href="#1-快照" class="headerlink" title="1.快照"></a>1.快照</h3><h4 id="1-1-原理"><a href="#1-1-原理" class="headerlink" title="1.1 原理"></a>1.1 原理</h4><p>Redis 使用操作系统的多进程机制来实现快照持久化：Redis 在持久化时，会调用 glibc 函数 fork 一个<br>子进程，然后将快照持久化操作完全交给子进程去处理，而父进程则继续处理客户端请求。在这个过程<br>中，子进程能够看到的内存中的数据在子进程产生的一瞬间就固定下来了，再也不会改变，也就是为什<br>么 Redis 持久化叫做 快照。</p>
<h4 id="1-2-具体配置"><a href="#1-2-具体配置" class="headerlink" title="1.2 具体配置"></a>1.2 具体配置</h4><p>在 Redis 中，默认情况下，快照持久化的方式就是开启的。<br>默认情况下会产生一个 dump.rdb 文件，这个文件就是备份下来的文件。当 Redis 启动时，会自动的去<br>加载这个 rdb 文件，从该文件中恢复数据。<br>具体的配置，在 redis.conf 中：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 表示快照的频率，第一个表示 900 秒内如果有一个键被修改，则进行快照</span><br><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br><span class="line"># 快照执行出错后，是否继续处理客户端的写命令</span><br><span class="line">stop-writes-on-bgsave-error yes</span><br><span class="line"># 是否对快照文件进行压缩</span><br><span class="line">rdbcompression yes</span><br><span class="line"># 表示生成的快照文件名</span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"># 表示生成的快照文件位置</span><br><span class="line">dir ./</span><br></pre></td></tr></tbody></table></figure>

<h4 id="1-3-备份流程"><a href="#1-3-备份流程" class="headerlink" title="1.3 备份流程"></a>1.3 备份流程</h4><ol>
<li><p>在 Redis 运行过程中，我们可以向 Redis 发送一条 save 命令来创建一个快照。但是需要注意，<br>save 是一个阻塞命令，Redis 在收到 save 命令开始处理备份操作之后，在处理完成之前，将不再<br>处理其他的请求。其他命令会被挂起，所以 save 使用的并不多。</p>
</li>
<li><p>我们一般可以使用 bgsave，bgsave 会 fork 一个子进程去处理备份的事情，不影响父进程处理客<br>户端请求。</p>
</li>
<li><p>我们定义的备份规则，如果有规则满足，也会自动触发 bgsave。</p>
</li>
<li><p>另外，当我们执行 shutdown 命令时，也会触发 save 命令，备份工作完成后，Redis 才会关闭。</p>
</li>
<li><p>用 Redis 搭建主从复制时，在 从机连上主机之后，会自动发送一条 sync 同步命令，主机收到命令<br>之后，首先执行 bgsave 对数据进行快照，然后才会给从机发送快照数据进行同步。</p>
</li>
</ol>
<h3 id="2-AOF"><a href="#2-AOF" class="headerlink" title="2.AOF"></a>2.AOF</h3><p>与快照持久化不同，AOF 持久化是将被执行的命令追加到 aof 文件末尾，在恢复时，只需要把记录下来<br>的命令从头到尾执行一遍即可。<br>默认情况下，AOF 是没有开启的。我们需要手动开启：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 开启 aof 配置</span><br><span class="line">appendonly yes</span><br><span class="line"># AOF 文件名</span><br><span class="line">appendfilename "appendonly.aof"</span><br><span class="line"># 备份的时机，下面的配置表示每秒钟备份一次</span><br><span class="line">appendfsync everysec</span><br><span class="line"># 表示 aof 文件在压缩时，是否还继续进行同步操作</span><br><span class="line">no-appendfsync-on-rewrite no</span><br><span class="line"># 表示当目前 aof 文件大小超过上一次重写时的 aof 文件大小的百分之多少的时候，再次进行重写</span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line"># 如果之前没有重写过，则以启动时的 aof 大小为依据，同时要求 aof 文件至少要大于 64M</span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br></pre></td></tr></tbody></table></figure>

<p>同时为了避免快照备份的影响，记得将快照备份关闭：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">save ""</span><br><span class="line">#save 900 1</span><br><span class="line">#save 300 10</span><br><span class="line">#save 60 10000</span><br></pre></td></tr></tbody></table></figure>

<h2 id="17-Redis-事务"><a href="#17-Redis-事务" class="headerlink" title="17.Redis 事务"></a>17.Redis 事务</h2><p>正常来说，一个可以商用的数据库往往都有比较完善的事务支持，Redis 当然也不例外。相对于 关系型<br>数据库中的事务模型，Redis 中的事务要简单很多。因为简单，所以 Redis 中的事务模型不太严格，所<br>以我们不能像使用关系型数据库中的事务那样来使用 Redis。</p>
<p>在关系型数据库中，和事务相关的三个指令分别是：<br>begin<br>commit<br>rollback</p>
<p>在 Redis 中，当然也有对应的指令：<br>multi<br>exec<br>discard</p>
<h3 id="1-原子性"><a href="#1-原子性" class="headerlink" title="1.原子性"></a>1.原子性</h3><p>注意，Redis 中的事务并不能算作原子性。它仅仅具备隔离性，也就是说当前的事务可以不被其他事务<br>打断。<br>由于每一次事务操作涉及到的指令还是比较多的，为了提高执行效率，我们在使用客户端的时候，可以<br>通过 pipeline 来优化指令的执行。<br>Redis 中还有一个 watch 指令，watch 可以用来监控一个 key，通过这种监控，我们可以确保在 exec<br>之前，watch 的键的没有被修改过。</p>
<h3 id="2-Java代码实现"><a href="#2-Java代码实现" class="headerlink" title="2.Java代码实现"></a>2.Java代码实现</h3></div><div class="article-licensing box"><div class="licensing-title"><p>最近的Redis笔记</p><p><a href="https://zeroornull.github.io/2021/05/16/redis笔记/">https://zeroornull.github.io/2021/05/16/redis笔记/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>Zeroornull</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2021-05-16</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2021-08-02</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/redis/">redis</a></div><div class="sharethis-inline-share-buttons"></div><script src="https://platform-api.sharethis.com/js/sharethis.js#property=60667abe39329f00123aea68&amp;product=sticky-share-buttons" defer></script></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" href="https://www.afdian.net/@zeroornull" target="_blank" rel="noopener" data-type="afdian"><span class="icon is-small"><i class="fas fa-charging-station"></i></span><span>爱发电</span></a><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="https://qr.alipay.com/fkx00721flijbw5hdn0kab5" alt="支付宝"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2021/06/01/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">LeetCode刷题笔记</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2021/05/14/db2window%E6%95%B0%E6%8D%AE%E5%8F%8A%E7%BB%93%E6%9E%84%E8%BF%81%E7%A7%BBlinux/"><span class="level-item">db2window数据及结构迁移linux</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="https://z3.ax1x.com/2021/07/27/WhycSH.gif" alt="Zeroornull"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Zeroornull</p><p class="is-size-6 is-block">just one newbie</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>ShangHai</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">21</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">15</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">15</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/zeroornull" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/zeroornull"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="SinaBlog" href="https://weibo.com/u/3027767592"><i class="fa-brands fa-weibo"></i></a></div></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#前言"><span class="level-left"><span class="level-item">1</span><span class="level-item">前言</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#2-Redis-简介"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">2.Redis 简介</span></span></a></li><li><a class="level is-mobile" href="#3-Redis-安装"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">3.Redis 安装</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#3-1-直接编译安装"><span class="level-left"><span class="level-item">1.2.1</span><span class="level-item">3.1 直接编译安装</span></span></a></li><li><a class="level is-mobile" href="#3-2-通过-Docker-安装"><span class="level-left"><span class="level-item">1.2.2</span><span class="level-item">3.2 通过 Docker 安装</span></span></a></li><li><a class="level is-mobile" href="#3-3-直接安装"><span class="level-left"><span class="level-item">1.2.3</span><span class="level-item">3.3 直接安装</span></span></a></li><li><a class="level is-mobile" href="#3-4-在线体验"><span class="level-left"><span class="level-item">1.2.4</span><span class="level-item">3.4 在线体验</span></span></a></li></ul></li><li><a class="level is-mobile" href="#4-Redis-五种基本数据类型"><span class="level-left"><span class="level-item">1.3</span><span class="level-item">4. Redis 五种基本数据类型</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#4-1-Redis-启动"><span class="level-left"><span class="level-item">1.3.1</span><span class="level-item">4.1 Redis 启动</span></span></a></li><li><a class="level is-mobile" href="#4-2-String"><span class="level-left"><span class="level-item">1.3.2</span><span class="level-item">4.2 String</span></span></a></li><li><a class="level is-mobile" href="#4-3-List"><span class="level-left"><span class="level-item">1.3.3</span><span class="level-item">4.3 List</span></span></a></li><li><a class="level is-mobile" href="#4-4-Set"><span class="level-left"><span class="level-item">1.3.4</span><span class="level-item">4.4 Set</span></span></a></li><li><a class="level is-mobile" href="#4-5-Hash"><span class="level-left"><span class="level-item">1.3.5</span><span class="level-item">4.5 Hash</span></span></a></li><li><a class="level is-mobile" href="#4-6-ZSet"><span class="level-left"><span class="level-item">1.3.6</span><span class="level-item">4.6 ZSet</span></span></a></li><li><a class="level is-mobile" href="#4-7-key"><span class="level-left"><span class="level-item">1.3.7</span><span class="level-item">4.7 key</span></span></a></li><li><a class="level is-mobile" href="#4-8-补充"><span class="level-left"><span class="level-item">1.3.8</span><span class="level-item">4.8 补充</span></span></a></li></ul></li><li><a class="level is-mobile" href="#5-Redis-的-Java-客户端"><span class="level-left"><span class="level-item">1.4</span><span class="level-item">5.Redis 的 Java 客户端</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#5-1-开启远程连接"><span class="level-left"><span class="level-item">1.4.1</span><span class="level-item">5.1 开启远程连接</span></span></a></li><li><a class="level is-mobile" href="#5-2-Jedis"><span class="level-left"><span class="level-item">1.4.2</span><span class="level-item">5.2 Jedis</span></span></a></li><li><a class="level is-mobile" href="#5-3-Lettuce"><span class="level-left"><span class="level-item">1.4.3</span><span class="level-item">5.3 Lettuce</span></span></a></li></ul></li><li><a class="level is-mobile" href="#6-Redis-做分布式锁"><span class="level-left"><span class="level-item">1.5</span><span class="level-item">6.Redis 做分布式锁</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#6-1-基本用法"><span class="level-left"><span class="level-item">1.5.1</span><span class="level-item">6.1 基本用法</span></span></a></li><li><a class="level is-mobile" href="#6-2-解决超时问题"><span class="level-left"><span class="level-item">1.5.2</span><span class="level-item">6.2 解决超时问题</span></span></a></li></ul></li><li><a class="level is-mobile" href="#7-Redis-做消息队列"><span class="level-left"><span class="level-item">1.6</span><span class="level-item">7.Redis 做消息队列</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#7-1-消息队列"><span class="level-left"><span class="level-item">1.6.1</span><span class="level-item">7.1 消息队列</span></span></a></li><li><a class="level is-mobile" href="#7-2-延迟消息队列"><span class="level-left"><span class="level-item">1.6.2</span><span class="level-item">7.2 延迟消息队列</span></span></a></li></ul></li><li><a class="level is-mobile" href="#8-再谈-Bit-操作"><span class="level-left"><span class="level-item">1.7</span><span class="level-item">8.再谈 Bit 操作</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#8-1-基本介绍"><span class="level-left"><span class="level-item">1.7.1</span><span class="level-item">8.1 基本介绍</span></span></a></li><li><a class="level is-mobile" href="#8-2-基本操作"><span class="level-left"><span class="level-item">1.7.2</span><span class="level-item">8.2 基本操作</span></span></a></li><li><a class="level is-mobile" href="#8-3-统计"><span class="level-left"><span class="level-item">1.7.3</span><span class="level-item">8.3 统计</span></span></a></li><li><a class="level is-mobile" href="#8-4-Bit-批处理"><span class="level-left"><span class="level-item">1.7.4</span><span class="level-item">8.4 Bit 批处理</span></span></a></li></ul></li><li><a class="level is-mobile" href="#9-HyperLogLog"><span class="level-left"><span class="level-item">1.8</span><span class="level-item">9.HyperLogLog</span></span></a></li><li><a class="level is-mobile" href="#10-布隆过滤器"><span class="level-left"><span class="level-item">1.9</span><span class="level-item">10.布隆过滤器</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#10-1-场景重现"><span class="level-left"><span class="level-item">1.9.1</span><span class="level-item">10.1 场景重现</span></span></a></li><li><a class="level is-mobile" href="#10-2-Bloom-Filter-介绍"><span class="level-left"><span class="level-item">1.9.2</span><span class="level-item">10.2 Bloom Filter 介绍</span></span></a></li><li><a class="level is-mobile" href="#10-3-Bloom-Filter-原理"><span class="level-left"><span class="level-item">1.9.3</span><span class="level-item">10.3 Bloom Filter 原理</span></span></a></li><li><a class="level is-mobile" href="#10-4-Bloom-Filter-安装"><span class="level-left"><span class="level-item">1.9.4</span><span class="level-item">10.4 Bloom Filter 安装</span></span></a></li><li><a class="level is-mobile" href="#10-5-基本用法"><span class="level-left"><span class="level-item">1.9.5</span><span class="level-item">10.5 基本用法</span></span></a></li><li><a class="level is-mobile" href="#10-6-典型场景"><span class="level-left"><span class="level-item">1.9.6</span><span class="level-item">10.6 典型场景</span></span></a></li></ul></li><li><a class="level is-mobile" href="#11-Redis-限流"><span class="level-left"><span class="level-item">1.10</span><span class="level-item">11.Redis 限流</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#11-1-预备知识"><span class="level-left"><span class="level-item">1.10.1</span><span class="level-item">11.1 预备知识</span></span></a></li><li><a class="level is-mobile" href="#11-2-简单限流"><span class="level-left"><span class="level-item">1.10.2</span><span class="level-item">11.2 简单限流</span></span></a></li><li><a class="level is-mobile" href="#11-3-深入限流操作"><span class="level-left"><span class="level-item">1.10.3</span><span class="level-item">11.3 深入限流操作</span></span></a></li><li><a class="level is-mobile" href="#11-4-Lettuce扩展"><span class="level-left"><span class="level-item">1.10.4</span><span class="level-item">11.4 Lettuce扩展</span></span></a></li></ul></li><li><a class="level is-mobile" href="#12-Redis-之-Geo"><span class="level-left"><span class="level-item">1.11</span><span class="level-item">12.Redis 之 Geo</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#1-GeoHash"><span class="level-left"><span class="level-item">1.11.1</span><span class="level-item">1.GeoHash</span></span></a></li><li><a class="level is-mobile" href="#Redis-中使用"><span class="level-left"><span class="level-item">1.11.2</span><span class="level-item">Redis 中使用</span></span></a></li></ul></li><li><a class="level is-mobile" href="#13-Redis-之-Scan"><span class="level-left"><span class="level-item">1.12</span><span class="level-item">13.Redis 之 Scan</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#1-简单介绍"><span class="level-left"><span class="level-item">1.12.1</span><span class="level-item">1.简单介绍</span></span></a></li><li><a class="level is-mobile" href="#2-基本用法"><span class="level-left"><span class="level-item">1.12.2</span><span class="level-item">2.基本用法</span></span></a></li><li><a class="level is-mobile" href="#3-原理"><span class="level-left"><span class="level-item">1.12.3</span><span class="level-item">3.原理</span></span></a></li><li><a class="level is-mobile" href="#4-其他用法"><span class="level-left"><span class="level-item">1.12.4</span><span class="level-item">4.其他用法</span></span></a></li></ul></li><li><a class="level is-mobile" href="#14-Redis-单线程如何处理高并发"><span class="level-left"><span class="level-item">1.13</span><span class="level-item">14.Redis 单线程如何处理高并发</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#1-阻塞-IO-与非阻塞-IO"><span class="level-left"><span class="level-item">1.13.1</span><span class="level-item">1.阻塞 IO 与非阻塞 IO</span></span></a></li><li><a class="level is-mobile" href="#2-Redis-的线程模型"><span class="level-left"><span class="level-item">1.13.2</span><span class="level-item">2.Redis 的线程模型</span></span></a></li></ul></li><li><a class="level is-mobile" href="#15-Redis-通信协议"><span class="level-left"><span class="level-item">1.14</span><span class="level-item">15.Redis 通信协议</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#1-准备工作"><span class="level-left"><span class="level-item">1.14.1</span><span class="level-item">1.准备工作</span></span></a></li><li><a class="level is-mobile" href="#2-实战"><span class="level-left"><span class="level-item">1.14.2</span><span class="level-item">2. 实战</span></span></a></li></ul></li><li><a class="level is-mobile" href="#16-Redis-持久化"><span class="level-left"><span class="level-item">1.15</span><span class="level-item">16.Redis 持久化</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#1-快照"><span class="level-left"><span class="level-item">1.15.1</span><span class="level-item">1.快照</span></span></a></li><li><a class="level is-mobile" href="#2-AOF"><span class="level-left"><span class="level-item">1.15.2</span><span class="level-item">2.AOF</span></span></a></li></ul></li><li><a class="level is-mobile" href="#17-Redis-事务"><span class="level-left"><span class="level-item">1.16</span><span class="level-item">17.Redis 事务</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#1-原子性"><span class="level-left"><span class="level-item">1.16.1</span><span class="level-item">1.原子性</span></span></a></li><li><a class="level is-mobile" href="#2-Java代码实现"><span class="level-left"><span class="level-item">1.16.2</span><span class="level-item">2.Java代码实现</span></span></a></li></ul></li></ul></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile" href="https://bulma.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bulma</span></span><span class="level-right"><span class="level-item tag">bulma.io</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/DeepLearning/"><span class="level-start"><span class="level-item">DeepLearning</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Java/"><span class="level-start"><span class="level-item">Java</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Java%E5%B9%B6%E5%8F%91/"><span class="level-start"><span class="level-item">Java并发</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/SpringCloud/"><span class="level-start"><span class="level-item">SpringCloud</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/db2/"><span class="level-start"><span class="level-item">db2</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/eladmin/"><span class="level-start"><span class="level-item">eladmin</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/es/"><span class="level-start"><span class="level-item">es</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/githubpage/"><span class="level-start"><span class="level-item">githubpage</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/linux/"><span class="level-start"><span class="level-item">linux</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/nginx/"><span class="level-start"><span class="level-item">nginx</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/redis/"><span class="level-start"><span class="level-item">redis</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/sql/"><span class="level-start"><span class="level-item">sql</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/vue/"><span class="level-start"><span class="level-item">vue</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%B0%8F%E5%AD%A6%E7%94%9F%E4%BD%9C%E6%96%87-%E6%88%91%E7%9A%84%E7%94%9F%E6%B4%BB/"><span class="level-start"><span class="level-item">小学生作文-我的生活</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%AE%97%E6%B3%95/"><span class="level-start"><span class="level-item">算法</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-09-15T05:18:05.000Z">2021-09-15</time></p><p class="title"><a href="/2021/09/15/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/">Java并发编程实战</a></p><p class="categories"><a href="/categories/Java%E5%B9%B6%E5%8F%91/">Java并发</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-08-15T01:28:25.000Z">2021-08-15</time></p><p class="title"><a href="/2021/08/15/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98_%E6%A0%B8%E5%BF%83%E7%AF%87_%E7%AC%94%E8%AE%B0/">Java并发编程实战_核心篇笔记</a></p><p class="categories"><a href="/categories/Java/">Java</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-08-13T00:28:25.000Z">2021-08-13</time></p><p class="title"><a href="/2021/08/13/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/">Java线程池学习总结</a></p><p class="categories"><a href="/categories/Java/">Java</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-08-03T15:40:07.000Z">2021-08-03</time></p><p class="title"><a href="/2021/08/03/%E8%B7%AF%E4%B8%8A%E7%9A%84%E7%8B%97%E5%AD%90/">路上的狗子</a></p><p class="categories"><a href="/categories/%E5%B0%8F%E5%AD%A6%E7%94%9F%E4%BD%9C%E6%96%87-%E6%88%91%E7%9A%84%E7%94%9F%E6%B4%BB/">小学生作文-我的生活</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-07-29T14:25:07.000Z">2021-07-29</time></p><p class="title"><a href="/2021/07/29/%E6%99%9A%E4%B8%8A10%E7%82%B9%E5%87%BA%E9%97%A8%E6%90%9E%E5%A4%9C%E5%AE%B5/">晚上10点出门搞夜宵</a></p><p class="categories"><a href="/categories/%E5%B0%8F%E5%AD%A6%E7%94%9F%E4%BD%9C%E6%96%87-%E6%88%91%E7%9A%84%E7%94%9F%E6%B4%BB/">小学生作文-我的生活</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2021/09/"><span class="level-start"><span class="level-item">九月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/08/"><span class="level-start"><span class="level-item">八月 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/07/"><span class="level-start"><span class="level-item">七月 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/06/"><span class="level-start"><span class="level-item">六月 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/05/"><span class="level-start"><span class="level-item">五月 2021</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/04/"><span class="level-start"><span class="level-item">四月 2021</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/10/"><span class="level-start"><span class="level-item">十月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/DeepLearning/"><span class="tag">DeepLearning</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Java/"><span class="tag">Java</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Java%E5%B9%B6%E5%8F%91/"><span class="tag">Java并发</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/SpringCloud/"><span class="tag">SpringCloud</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/db2/"><span class="tag">db2</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/eladmin/"><span class="tag">eladmin</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/es/"><span class="tag">es</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/githubpage/"><span class="tag">githubpage</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/linux/"><span class="tag">linux</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/nginx/"><span class="tag">nginx</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/redis/"><span class="tag">redis</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/sql/"><span class="tag">sql</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vue/"><span class="tag">vue</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%B0%8F%E5%AD%A6%E7%94%9F%E4%BD%9C%E6%96%87-%E6%88%91%E7%9A%84%E7%94%9F%E6%B4%BB/"><span class="tag">小学生作文-我的生活</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%AE%97%E6%B3%95/"><span class="tag">算法</span><span class="tag">1</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">Zeroornull</a><p class="is-size-7"><span>&copy; 2022 Zeroornull</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><a href="http://www.beian.miit.gov.cn/" target="_blank">皖ICP备2021011041号-1</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>