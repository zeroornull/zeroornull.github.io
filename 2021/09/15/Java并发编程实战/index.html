<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="theme-color" content="#123456"><meta name="generator" content="Hexo 4.2.0"><meta><title>Java并发编程实战 - Zeroornull</title><link rel="manifest" href="/manifest.json"><meta name="theme-color" content="#3273dc"><meta name="application-name" content="zeroornull"><meta name="msapplication-TileImage" content="icons/touch-icon-iphone.png"><meta name="msapplication-TileColor" content="#3273dc"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="zeroornull"><meta name="apple-mobile-web-app-status-bar-style" content="default"><link rel="apple-touch-icon" sizes="144x144" href="icons/touch-icon-iphone.png"><link rel="apple-touch-icon" sizes="152x152" href="icons/touch-icon-ipad.png"><link rel="apple-touch-icon" sizes="72x72" href="icon/logo.ico"><link rel="apple-touch-icon" sizes="96x96" href="icon/logo.ico"><link rel="apple-touch-icon" sizes="128x128" href="icon/logo.ico"><link rel="apple-touch-icon" sizes="256x256" href="icon/logo.ico"><meta name="description" content="Java并发编程实战"><meta property="og:type" content="blog"><meta property="og:title" content="Java并发编程实战"><meta property="og:url" content="https://zeroornull.github.io/2021/09/15/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/"><meta property="og:site_name" content="Zeroornull"><meta property="og:description" content="Java并发编程实战"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://gitee.com/penno/blogimg/raw/master/img/20210914155458.png"><meta property="article:published_time" content="2021-09-15T05:18:05.000Z"><meta property="article:modified_time" content="2021-09-15T05:18:05.873Z"><meta property="article:author" content="Zeroornull"><meta property="article:tag" content="Java并发"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://gitee.com/penno/blogimg/raw/master/img/20210914155458.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://zeroornull.github.io/2021/09/15/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/"},"headline":"Java并发编程实战","image":["https://gitee.com/penno/blogimg/raw/master/img/20210914155458.png"],"datePublished":"2021-09-15T05:18:05.000Z","dateModified":"2021-09-15T05:18:05.873Z","author":{"@type":"Person","name":"Zeroornull"},"description":"Java并发编程实战"}</script><link rel="canonical" href="https://zeroornull.github.io/2021/09/15/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/"><link rel="alternate" href="/path/to/atom.xml" title="Zeroornull" type="application/atom+xml"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!-->
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">Zeroornull</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="GitHub" href="https://github.com">GitHub</a><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/zeroornull"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-09-15T05:18:05.000Z" title="2021/9/15 下午1:18:05">2021-09-15</time>发表</span><span class="level-item"><time dateTime="2021-09-15T05:18:05.873Z" title="2021/9/15 下午1:18:05">2021-09-15</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Java%E5%B9%B6%E5%8F%91/">Java并发</a></span><span class="level-item">1 小时读完 (大约9369个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">Java并发编程实战</h1><div class="content"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>   Java并发编程实战</p>
<span id="more"></span>

<h1 id="Java并发编程实战"><a href="#Java并发编程实战" class="headerlink" title="Java并发编程实战"></a>Java并发编程实战</h1><p><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/100023901">https://time.geekbang.org/column/intro/100023901</a></p>
<h2 id="01-可见性、原子性和有序性问题：并发编程Bug的源头"><a href="#01-可见性、原子性和有序性问题：并发编程Bug的源头" class="headerlink" title="01 | 可见性、原子性和有序性问题：并发编程Bug的源头"></a>01 | 可见性、原子性和有序性问题：并发编程Bug的源头</h2><p>源头之一：缓存导致的可见性问题</p>
<p>源头之二：线程切换带来的原子性问题</p>
<p>源头之三：编译优化带来的有序性问题</p>
<p><strong>在 32 位的机器上对 long 型变量进行加减操作存在并发隐患?</strong></p>
<p>long类型64位，所以在32位的机器上，对long类型的数据操作通常需要多条指令组合出<br>来，无法保证原子性，所以并发的时候会出问题</p>
<h2 id="02-Java内存模型：看Java如何解决可见性和有序性问题"><a href="#02-Java内存模型：看Java如何解决可见性和有序性问题" class="headerlink" title="02 | Java内存模型：看Java如何解决可见性和有序性问题"></a>02 | Java内存模型：看Java如何解决可见性和有序性问题</h2><p>volatile 关键字并不是 Java 语言的特产，古老的 C 语言里也有，它最原始的意义就是禁用 CPU 缓存。</p>
<h3 id="Happens-Before-规则"><a href="#Happens-Before-规则" class="headerlink" title="Happens-Before 规则"></a>Happens-Before 规则</h3><p>前面一个操作的结果对后续操作是可见的。</p>
<h4 id="1-程序的顺序性规则"><a href="#1-程序的顺序性规则" class="headerlink" title="1. 程序的顺序性规则"></a>1. 程序的顺序性规则</h4><p>这条规则是指在一个线程中，按照程序顺序，前面的操作 Happens-Before 于后续的任意操作。</p>
<h4 id="2-volatile-变量规则"><a href="#2-volatile-变量规则" class="headerlink" title="2. volatile 变量规则"></a>2. volatile 变量规则</h4><p>对一个 volatile 变量的写操作， Happens-Before 于后续对这个 volatile变量的读操作。</p>
<h4 id="3-传递性"><a href="#3-传递性" class="headerlink" title="3. 传递性"></a>3. 传递性</h4><p>这条规则是指如果 A Happens-Before B，且 B Happens-Before C，那么 A Happens-Before C。</p>
<h4 id="4-管程中锁的规则"><a href="#4-管程中锁的规则" class="headerlink" title="4. 管程中锁的规则"></a>4. 管程中锁的规则</h4><p>对一个锁的解锁 Happens-Before 于后续对这个锁的加锁。</p>
<p>管程是一种通用的同步原语，在Java 中指的就是 synchronized，synchronized 是 Java 里对管程的实现。</p>
<h4 id="5-线程-start-规则"><a href="#5-线程-start-规则" class="headerlink" title="5. 线程 start() 规则"></a>5. 线程 start() 规则</h4><p>主线程 A 启动子线程 B 后，子线程 B 能够看到主线程在启动子线程 B 前的操作。</p>
<h4 id="6-线程-join-规则"><a href="#6-线程-join-规则" class="headerlink" title="6. 线程 join() 规则"></a>6. 线程 join() 规则</h4><p>主线程 A 等待子线程 B 完成（主线程 A 通过调用子线程B 的 join() 方法实现），当子线程 B 完成后（主线程 A 中 join() 方法返回），主线程能够看到子线程的操作。当然所谓的“看到”，指的是对共享变量的操作。</p>
<h4 id="线程中断规则："><a href="#线程中断规则：" class="headerlink" title="线程中断规则："></a>线程中断规则：</h4><p>对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测到是否有中断发生。</p>
<h4 id="对象终结规则："><a href="#对象终结规则：" class="headerlink" title="对象终结规则："></a>对象终结规则：</h4><p>一个对象的初始化完成(构造函数执行结束)先行发生于它的finalize()方法的开始。</p>
<p><strong>课后题</strong></p>
<p>有一个共享变量 abc，在一个线程里设置了 abc 的值 abc=3，你思考一下，有哪些办法可以让其他线程能够看到abc==3？</p>
<p>1.声明共享变量abc，并使用volatile关键字修饰abc<br>2.声明共享变量abc，在synchronized关键字对abc的赋值代码块加锁，由于Happenbefore<br>管程锁的规则，可以使得后续的线程可以看到abc的值。</p>
<h2 id="03-互斥锁（上）：解决原子性问题"><a href="#03-互斥锁（上）：解决原子性问题" class="headerlink" title="03 | 互斥锁（上）：解决原子性问题"></a>03 | 互斥锁（上）：解决原子性问题</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面的代码用 synchronized 修饰代码块来尝试解决并发问题，你觉得这个使用方式正确吗？有哪些问题呢？能解决可见性和原子性问题吗？</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SafeCalc</span> </span>{</span><br><span class="line">    <span class="keyword">long</span> value = <span class="number">0L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">get</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">new</span> Object()) {</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addOne</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">new</span> Object()) {</span><br><span class="line">            value += <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>加锁本质就是在锁对象的对象头中写入当前线程id，但是new object每次在内存中都是新对象，所以加锁无效。</p>
<p><strong>JVM 开启逃逸分析之后，synchronized (new Object()) 这行代码在实际执行的时候会被优化掉，也就是说在真实执行的时候，这行代码压根就不存在。</strong></p>
<h2 id="04-互斥锁（下）：如何用一把锁保护多个资源？"><a href="#04-互斥锁（下）：如何用一把锁保护多个资源？" class="headerlink" title="04 | 互斥锁（下）：如何用一把锁保护多个资源？"></a>04 | 互斥锁（下）：如何用一把锁保护多个资源？</h2><p>用Account.class 作为共享的锁</p>
<p>Account.class 是所有 Account 对象共享的，而且这个对象是 Java 虚拟机在加载 Account 类的时候创建的，所以我们不用担心它的唯一性。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>{</span><br><span class="line">    <span class="comment">// lock for balance</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object balLock = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="comment">// balance</span></span><br><span class="line">    <span class="keyword">private</span> Integer balance;</span><br><span class="line">    <span class="comment">// lock for password</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object pwLock = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="comment">// password</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// withdraw money</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">withdraw</span><span class="params">(Integer amt)</span> </span>{</span><br><span class="line">        <span class="keyword">synchronized</span> (balLock) {</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.balance &gt; amt) {</span><br><span class="line">                <span class="keyword">this</span>.balance -= amt;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// show balance</span></span><br><span class="line">    <span class="function">Integer <span class="title">getBalance</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">synchronized</span> (balLock) {</span><br><span class="line">            <span class="keyword">return</span> balance;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// change password</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">updatePassword</span><span class="params">(String pw)</span> </span>{</span><br><span class="line">        <span class="keyword">synchronized</span> (pwLock) {</span><br><span class="line">            <span class="keyword">this</span>.password = pw;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// show password</span></span><br><span class="line">    <span class="function">String <span class="title">getPassword</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">synchronized</span> (pwLock) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.password;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// transfer</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Account target, <span class="keyword">int</span> amt)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.balance &gt; amt) {</span><br><span class="line">            <span class="keyword">this</span>.balance -= amt;</span><br><span class="line">            target.balance += amt;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在第一个示例程序里，我们用了两把不同的锁来分别保护账户余额、账户密码，创建锁的时候，我们用的是：private final Object xxxLock = new Object();，如果账户余额用 this.balance 作为互斥锁，账户密码用 this.password 作为互斥锁，你觉得是否可以呢？</p>
<p>用this.balance 和this.password 都不行。在同一个账户多线程访问时候，A线程取款进行this.balance-=amt;时候此时this.balance对应的值已经发生变换，线程B再次取款时拿到的balance对应的值并不是A线程中的，也就是说不能把可变的对象当成一把锁。this.password 虽然说是String修饰但也会改变，所以也不行。</p>
<h2 id="05-一不小心就死锁了，怎么办？"><a href="#05-一不小心就死锁了，怎么办？" class="headerlink" title="05 | 一不小心就死锁了，怎么办？"></a>05 | 一不小心就死锁了，怎么办？</h2><h3 id="如何预防死锁"><a href="#如何预防死锁" class="headerlink" title="如何预防死锁"></a>如何预防死锁</h3><ol>
<li><p>互斥，共享资源 X 和 Y 只能被一个线程占用；</p>
</li>
<li><p>占有且等待，线程 T1 已经取得共享资源 X，在等待共享资源 Y 的时候，不释放共享资源 X；</p>
</li>
<li><p>不可抢占，其他线程不能强行抢占线程 T1 占有的资源；</p>
</li>
<li><p>循环等待，线程 T1 等待线程 T2 占有的资源，线程 T2 等待线程 T1 占有的资源，就是循环等<br> 待。</p>
</li>
</ol>
<ol>
<li>对于“占用且等待”这个条件，我们可以一次性申请所有的资源，这样就不存在等待了。</li>
<li>对于“不可抢占”这个条件，占用部分资源的线程进一步申请其他资源时，如果申请不到，可<br>以主动释放它占有的资源，这样不可抢占这个条件就破坏掉了。</li>
<li>对于“循环等待”这个条件，可以靠按序申请资源来预防。所谓按序申请，是指资源是有线性<br>顺序的，申请的时候可以先申请资源序号小的，再申请资源序号大的，这样线性化后自然就不<br>存在循环了。</li>
</ol>
<h3 id="1-破坏占用且等待条件"><a href="#1-破坏占用且等待条件" class="headerlink" title="1. 破坏占用且等待条件"></a>1. 破坏占用且等待条件</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Allocator</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> List&lt;Object&gt; als = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// allocate resource in one time</span></span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">apply</span><span class="params">(Object from, Object to)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (als.contains(from) || als.contains(to)) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            als.add(from);</span><br><span class="line">            als.add(to);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// return resource</span></span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">free</span><span class="params">(Object from, Object to)</span> </span>{</span><br><span class="line">        als.remove(from);</span><br><span class="line">        als.remove(to);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>{</span><br><span class="line">    <span class="comment">// actr should be single_instance </span></span><br><span class="line">    <span class="keyword">private</span> Allocator actr;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> balance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// transfer</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Account target, <span class="keyword">int</span> amt)</span> </span>{</span><br><span class="line">        <span class="comment">// apply transfer from or to until success </span></span><br><span class="line">        <span class="keyword">while</span> (!actr.apply(<span class="keyword">this</span>, target)) {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="keyword">synchronized</span> (target) {</span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">this</span>.balance &gt; amt) {</span><br><span class="line">                        <span class="keyword">this</span>.balance -= amt;</span><br><span class="line">                        target.balance += amt;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            } <span class="keyword">finally</span> {</span><br><span class="line">                actr.free(<span class="keyword">this</span>, target);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// for 3</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">transfer1</span><span class="params">(Account target, <span class="keyword">int</span> amt)</span> </span>{</span><br><span class="line">        Account left = <span class="keyword">this</span>;</span><br><span class="line">        Account right = target;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.id &gt; target.id) {</span><br><span class="line">            left = target;</span><br><span class="line">            right = <span class="keyword">this</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// lock small number</span></span><br><span class="line">        <span class="keyword">synchronized</span> (left) {</span><br><span class="line">            <span class="comment">// lock big number</span></span><br><span class="line">            <span class="keyword">synchronized</span> (right) {</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.balance &gt; amt) {</span><br><span class="line">                    <span class="keyword">this</span>.balance -= amt;</span><br><span class="line">                    target.balance += amt;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="2-破坏不可抢占条件"><a href="#2-破坏不可抢占条件" class="headerlink" title="2. 破坏不可抢占条件"></a>2. 破坏不可抢占条件</h3><h3 id="3-破坏循环等待条件"><a href="#3-破坏循环等待条件" class="headerlink" title="3. 破坏循环等待条件"></a>3. 破坏循环等待条件</h3><h3 id="课后题"><a href="#课后题" class="headerlink" title="课后题"></a>课后题</h3><p>破坏占用且等待条件，我们也是锁了所有的账户，而且还是用了死循环while(!actr.apply(this, target));这个方法，那它比 synchronized(Account.class)有没有性能优势呢？</p>
<p>synchronized(Account.class) 锁了Account类相关的所有操作。相当于文中说的包场了，只要与Account有关联，通通需要等待当前线程操作完成。while死循环的方式只锁定了当前操作的两个相关的对象。两种影响到的范围不同。</p>
<h2 id="06-用“等待-通知”机制优化循环等待"><a href="#06-用“等待-通知”机制优化循环等待" class="headerlink" title="06 | 用“等待-通知”机制优化循环等待"></a>06 | 用“等待-通知”机制优化循环等待</h2><h3 id="一个更好地资源分配器"><a href="#一个更好地资源分配器" class="headerlink" title="一个更好地资源分配器"></a>一个更好地资源分配器</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Allocator</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> List&lt;Object&gt; als;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// apply all resource at once</span></span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">(Object from, Object to)</span> </span>{</span><br><span class="line">        <span class="comment">// classic writing</span></span><br><span class="line">        <span class="keyword">while</span> (als.contains(from) || als.contains(to)) {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                wait();</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        als.add(from);</span><br><span class="line">        als.add(to);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// return resource</span></span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">free</span><span class="params">(Object from, Object to)</span> </span>{</span><br><span class="line">        als.remove(from);</span><br><span class="line">        als.remove(to);</span><br><span class="line">        notifyAll();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h3 id="尽量使用-notifyAll"><a href="#尽量使用-notifyAll" class="headerlink" title="尽量使用 notifyAll()"></a>尽量使用 notifyAll()</h3><p>notify() 是会随机地通知等待队列中的一个线程，而 notifyAll() 会通知等待队列中的所有线程。</p>
<h3 id="课后题-1"><a href="#课后题-1" class="headerlink" title="课后题"></a>课后题</h3><p>wait() 方法和 sleep() 方法都能让当前线程挂起一段时间，那它们的区别是什么？</p>
<p>wait与sleep区别在于：</p>
<ol>
<li>wait会释放所有锁而sleep不会释放锁资源.</li>
<li>wait只能在同步方法和同步块中使用，而sleep任何地方都可以.</li>
<li>wait无需捕捉异常，而sleep需要.</li>
</ol>
<p>两者相同点：都会让渡CPU执行时间，等待再次调度！</p>
<h2 id="07-安全性、活跃性以及性能问题"><a href="#07-安全性、活跃性以及性能问题" class="headerlink" title="07 | 安全性、活跃性以及性能问题"></a>07 | 安全性、活跃性以及性能问题</h2><h3 id="课后思考"><a href="#课后思考" class="headerlink" title="课后思考"></a>课后思考</h3><p>Java 语言提供的 Vector 是一个线程安全的容器，有同学写了下面的代码，你看看是否存在并发问题呢？</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addIfNotExist</span><span class="params">(Vector v,Object o)</span></span>{</span><br><span class="line">    <span class="keyword">if</span>(!v.contains(o)) {</span><br><span class="line">        v.add(o);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">// contains和add之间不是原子操作，有可能重复添加。</span></span><br><span class="line"><span class="comment">// vector是线程安全，指的是它方法单独执行的时候没有并发正确性问题，并不代表把它的操作组合在一起问木有，而这个程序显然有竞态条件问题。</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="08-管程：并发编程的万能钥匙"><a href="#08-管程：并发编程的万能钥匙" class="headerlink" title="08 | 管程：并发编程的万能钥匙"></a>08 | 管程：并发编程的万能钥匙</h2><h3 id="课后思考-1"><a href="#课后思考-1" class="headerlink" title="课后思考"></a>课后思考</h3><p>wait() 方法，在 Hasen 模型和 Hoare 模型里面，都是没有参数的，而在 MESA 模型里面，增加了超时参数，你觉得这个参数有必要吗？</p>
<p>1.由于是while 循环，所以就算超时自动唤醒也会去重新检查条件，所以不存在逻辑错误问题<br>2.假设另外一个线程在唤醒之前因为某些原因退出了，那带参数的notify可以超时而进去就绪状态。</p>
<p>hasen 是执行完，再去唤醒另外一个线程。能够保证线程的执行。hoare，是中断当前线程，唤醒另外一个线程，执行完再去唤醒，也能够保证完成。而mesa是进入等待队列，不一定有机会能够执行。</p>
<h2 id="09-Java线程（上）：Java线程的生命周期"><a href="#09-Java线程（上）：Java线程的生命周期" class="headerlink" title="09 | Java线程（上）：Java线程的生命周期"></a>09 | Java线程（上）：Java线程的生命周期</h2><h3 id="课后思考-2"><a href="#课后思考-2" class="headerlink" title="课后思考"></a>课后思考</h3><p>下面代码的本意是当前线程被中断之后，退出while(true)，你觉得这段代码是否正确呢？</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Thread th = Thread.currentThread();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) {</span><br><span class="line">            <span class="keyword">if</span> (th.isInterrupted()) {</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 省略业务代码无数</span></span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">        }</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可能出现无限循环，线程在sleep期间被打断了，抛出一个InterruptedException异常，try catch捕捉此异常，应该重置一下中断标示，因为抛出异常后，中断标示会自动清除掉！</span></span><br><span class="line">Thread th = Thread.currentThread();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) {</span><br><span class="line">            <span class="keyword">if</span> (th.isInterrupted()) {</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 省略业务代码无数</span></span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">        }</span><br></pre></td></tr></tbody></table></figure>

<h2 id="10-Java线程（中）：创建多少线程才是合适的？"><a href="#10-Java线程（中）：创建多少线程才是合适的？" class="headerlink" title="10 | Java线程（中）：创建多少线程才是合适的？"></a>10 | Java线程（中）：创建多少线程才是合适的？</h2><p>对于 CPU 密集型的计算场景，理论上“线程的数量 =CPU 核数”就是最合适的</p>
<p>对于 I/O 密集型计算场景，最佳的线程数是与程序中 CPU 计算和 I/O 操作的耗时比相关的，我们可以总结出这样一个公式：</p>
<p><strong>最佳线程数 =1 +（I/O 耗时 / CPU 耗时）</strong></p>
<p>不过上面这个公式是针对单核 CPU 的，至于多核 CPU，也很简单，只需要等比扩大就可以了，计算公式如下：</p>
<p><strong>最佳线程数 =CPU 核数 * [ 1 +（I/O 耗时 / CPU 耗时）]</strong></p>
<h3 id="课后思考-3"><a href="#课后思考-3" class="headerlink" title="课后思考"></a>课后思考</h3><p>对于最佳线程数的设置积累了一些经验值，认为对于 I/O 密集型应用，最佳线程数应该为：2 * CPU 的核数 + 1，你觉得这个经验值合理吗？</p>
<p>bu</p>
<h2 id="11-Java线程（下）：为什么局部变量是线程安全的？"><a href="#11-Java线程（下）：为什么局部变量是线程安全的？" class="headerlink" title="11| Java线程（下）：为什么局部变量是线程安全的？"></a>11| Java线程（下）：为什么局部变量是线程安全的？</h2><h3 id="课后思考-4"><a href="#课后思考-4" class="headerlink" title="课后思考"></a>课后思考</h3><p>常听人说，递归调用太深，可能导致栈溢出。你思考一下原因是什么？有哪些解决方案呢？</p>
<p>因为调用方法时局部变量会进线程的栈帧，线程的栈内存是有限的，而递归没控制好容易造成太多层次调用，最终栈溢出。<br>解决思路一是开源节流，即减少多余的局部变量或扩大栈内存大小设置，减少调用层次涉及具体业务逻辑，优化空间有限；二是改弦更张，即想办法消除递归，比如说能否改造成尾递归（Java会优化掉尾递归）</p>
<h2 id="12-如何用面向对象思想写好并发程序？"><a href="#12-如何用面向对象思想写好并发程序？" class="headerlink" title="12 | 如何用面向对象思想写好并发程序？"></a>12 | 如何用面向对象思想写好并发程序？</h2><h3 id="一、封装共享变量"><a href="#一、封装共享变量" class="headerlink" title="一、封装共享变量"></a>一、封装共享变量</h3><h3 id="二、识别共享变量间的约束条件"><a href="#二、识别共享变量间的约束条件" class="headerlink" title="二、识别共享变量间的约束条件"></a>二、识别共享变量间的约束条件</h3><h3 id="三、制定并发访问策略"><a href="#三、制定并发访问策略" class="headerlink" title="三、制定并发访问策略"></a>三、制定并发访问策略</h3><ol>
<li><p>避免共享：避免共享的技术主要是利于线程本地存储以及为每个任务分配独立的线程。</p>
</li>
<li><p>不变模式：这个在 Java 领域应用的很少，但在其他领域却有着广泛的应用，例如 Actor 模式、CSP 模式以及函数式编程的基础都是不变模式。</p>
</li>
<li><p>管程及其他同步工具：Java 领域万能的解决方案是管程，但是对于很多特定场景，使用 Java并发包提供的读写锁、并发容器等同步工具会更好。</p>
</li>
</ol>
<p>除了这些方案之外，还有一些宏观的原则需要你了解。这些宏观原则，有助于你写出“健壮”的并发程序。这些原则主要有以下三条。</p>
<ol>
<li><p>优先使用成熟的工具类：Java SDK 并发包里提供了丰富的工具类，基本上能满足你日常的需要，建议你熟悉它们，用好它们，而不是自己再“发明轮子”，毕竟并发工具类不是随随便便就能发明成功的。</p>
</li>
<li><p>迫不得已时才使用低级的同步原语：低级的同步原语主要指的是 synchronized、Lock、Semaphore 等，这些虽然感觉简单，但实际上并没那么简单，一定要小心使用。</p>
</li>
<li><p>避免过早优化：安全第一，并发程序首先要保证安全，出现性能瓶颈后再优化。在设计期和开发期，很多人经常会情不自禁地预估性能的瓶颈，并对此实施优化，但残酷的现实却是：性能瓶颈不是你想预估就能预估的。</p>
</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SafeWM</span> </span>{</span><br><span class="line">    <span class="comment">// inventory ceiling</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicLong upper = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// stock low limit</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicLong lower = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set stock high limit</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setUpper</span><span class="params">(<span class="keyword">long</span> v)</span> </span>{</span><br><span class="line">        <span class="comment">// check param in law</span></span><br><span class="line">        <span class="keyword">if</span> (v &lt; lower.get()) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        }</span><br><span class="line">        upper.set(v);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// set stock low limit</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setLower</span><span class="params">(<span class="keyword">long</span> v)</span> </span>{</span><br><span class="line">        <span class="comment">// check param in law</span></span><br><span class="line">        <span class="keyword">if</span> (v &gt; upper.get()) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        }</span><br><span class="line">        lower.set(v);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// omit other operation</span></span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="课后思考-5"><a href="#课后思考-5" class="headerlink" title="课后思考"></a>课后思考</h3><p>本期示例代码中，类 SafeWM 不满足库存下限要小于库存上限这个约束条件，那你来试试修改一下，让它能够在并发条件下满足库存下限要小于库存上限这个约束条件。</p>
<h2 id="13-理论基础模块热点问题答疑"><a href="#13-理论基础模块热点问题答疑" class="headerlink" title="13 | 理论基础模块热点问题答疑"></a>13 | 理论基础模块热点问题答疑</h2><h2 id="14-Lock-amp-Condition（上）：隐藏在并发包中的管程"><a href="#14-Lock-amp-Condition（上）：隐藏在并发包中的管程" class="headerlink" title="14 | Lock&amp;Condition（上）：隐藏在并发包中的管程"></a>14 | Lock&amp;Condition（上）：隐藏在并发包中的管程</h2><h3 id="什么是可重入锁"><a href="#什么是可重入锁" class="headerlink" title="什么是可重入锁"></a>什么是可重入锁</h3><p>所谓可重入锁，顾名思义，指的是线程可以重复获取同一把锁。</p>
<p>所谓可重入函数，指的是多个线程可以同时调用该函数，每个线程都能得到正确结果</p>
<h3 id="用锁的最佳实践"><a href="#用锁的最佳实践" class="headerlink" title="用锁的最佳实践"></a>用锁的最佳实践</h3><ol>
<li>永远只在更新对象的成员变量时加锁</li>
<li>永远只在访问可变的成员变量时加锁</li>
<li>永远不在调用其他对象的方法时加锁</li>
</ol>
<p><strong>并发问题，本来就难以诊断，所以你一定要让你的代码尽量安全，尽量简单，哪怕有一点可能会出问题，都要努力避免。</strong></p>
<h3 id="课后思考-6"><a href="#课后思考-6" class="headerlink" title="课后思考"></a>课后思考</h3><p>你已经知道 tryLock() 支持非阻塞方式获取锁，下面这段关于转账的程序就使用到了 tryLock()，你来看看，它是否存在死锁问题呢？</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> balance;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock lock</span><br><span class="line">            = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转账</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Account tar, <span class="keyword">int</span> amt)</span> </span>{</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) {</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.lock.tryLock()) {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    <span class="keyword">if</span> (tar.lock.tryLock()) {</span><br><span class="line">                        <span class="keyword">try</span> {</span><br><span class="line">                            <span class="keyword">this</span>.balance -= amt;</span><br><span class="line">                            tar.balance += amt;</span><br><span class="line">                        } <span class="keyword">finally</span> {</span><br><span class="line">                            tar.lock.unlock();</span><br><span class="line">                        }</span><br><span class="line">                    }<span class="comment">//if</span></span><br><span class="line">                } <span class="keyword">finally</span> {</span><br><span class="line">                    <span class="keyword">this</span>.lock.unlock();</span><br><span class="line">                }</span><br><span class="line">            }<span class="comment">//if</span></span><br><span class="line">        }<span class="comment">//while</span></span><br><span class="line">    }<span class="comment">//transfer</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> balance;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock lock</span><br><span class="line">            = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转账</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Account tar, <span class="keyword">int</span> amt)</span> </span>{</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) {</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.lock.tryLock()) {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    <span class="keyword">if</span> (tar.lock.tryLock()) {</span><br><span class="line">                        <span class="keyword">try</span> {</span><br><span class="line">                            <span class="keyword">this</span>.balance -= amt;</span><br><span class="line">                            tar.balance += amt;</span><br><span class="line"><span class="comment">//新增：退出循环</span></span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        } <span class="keyword">finally</span> {</span><br><span class="line">                            tar.lock.unlock();</span><br><span class="line">                        }</span><br><span class="line">                    }<span class="comment">//if</span></span><br><span class="line">                } <span class="keyword">finally</span> {</span><br><span class="line">                    <span class="keyword">this</span>.lock.unlock();</span><br><span class="line">                }</span><br><span class="line">            }<span class="comment">//if</span></span><br><span class="line"><span class="comment">//新增：sleep⼀个随机时间避免活锁</span></span><br><span class="line">            Thread.sleep(随机时间);</span><br><span class="line">        }<span class="comment">//while</span></span><br><span class="line">    }<span class="comment">//transfer</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h2 id="15-Lock和Condition（下）：Dubbo如何用管程实现异步转同步？"><a href="#15-Lock和Condition（下）：Dubbo如何用管程实现异步转同步？" class="headerlink" title="15 | Lock和Condition（下）：Dubbo如何用管程实现异步转同步？"></a>15 | Lock和Condition（下）：Dubbo如何用管程实现异步转同步？</h2><h3 id="课后思考-7"><a href="#课后思考-7" class="headerlink" title="课后思考"></a>课后思考</h3><p><strong>DefaultFuture 里面唤醒等待的线程，用的是 signal()，而不是 signalAll()，你来分析一下，这样做是否合理呢？</strong></p>
<p>每个rpc请求都会占用一个线程并产生一个新的DefaultFuture实例，它们的lock&amp;condition是不同的，并没有竞争关系<br>这里的lock&amp;condition是用来做异步转同步的，使get()方法不必等待timeout那么久，用得很巧妙</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RPC结果返回时调⽤该⽅法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReceived</span><span class="params">(Response res)</span> </span>{</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">response = res;</span><br><span class="line">done.signalAll();</span><br><span class="line">} <span class="keyword">finally</span> {</span><br><span class="line">lock.unlock();</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h2 id="16-Semaphore：如何快速实现一个限流器？"><a href="#16-Semaphore：如何快速实现一个限流器？" class="headerlink" title="16 | Semaphore：如何快速实现一个限流器？"></a>16 | Semaphore：如何快速实现一个限流器？</h2><p><strong>Semaphore 可以允许多个线程访问一个临界区。</strong></p>
<h3 id="课后思考-8"><a href="#课后思考-8" class="headerlink" title="课后思考"></a>课后思考</h3><p>在上面对象池的例子中，对象保存在了 Vector 中，Vector 是 Java 提供的线程安全的容器，如果我们把 Vector 换成 ArrayList，是否可以呢？</p>
<p>答案是不可以的。Semaphore可以允许多个线程访问一个临界区，那就意味着可能存在多个线程同时访问<br>ArrayList，而ArrayList不是线程安全的，所以对象池的例子中是不能够将Vector换成ArrayList的。<br>Semaphore允许多个线程访问一个临界区，这也是一把双刃剑，当多个线程进入临界区时，如果需要访问<br>共享变量就会存在并发问题，所以必须加锁，也就是说Semaphore需要锁中锁。</p>
<h2 id="17-ReadWriteLock：如何快速实现一个完备的缓存？"><a href="#17-ReadWriteLock：如何快速实现一个完备的缓存？" class="headerlink" title="17 | ReadWriteLock：如何快速实现一个完备的缓存？"></a>17 | ReadWriteLock：如何快速实现一个完备的缓存？</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//快速实现一个缓存</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cache</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>{</span><br><span class="line">    <span class="keyword">final</span> Map&lt;K, V&gt; m = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">final</span> ReadWriteLock rwl = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read lock</span></span><br><span class="line">    <span class="keyword">final</span> Lock r = rwl.readLock();</span><br><span class="line">    <span class="comment">// write lock</span></span><br><span class="line">    <span class="keyword">final</span> Lock w = rwl.writeLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read cache</span></span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">(K key)</span> </span>{</span><br><span class="line">        r.lock();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">return</span> m.get(key);</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            r.unlock();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// write cache</span></span><br><span class="line">    <span class="function">V <span class="title">put</span><span class="params">(K key, V v)</span> </span>{</span><br><span class="line">        w.lock();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">return</span> m.put(key, v);</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            w.unlock();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现缓存的按需加载</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cache</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>{</span><br><span class="line">    Object data;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> cacheValid;</span><br><span class="line">    <span class="keyword">final</span> Map&lt;K, V&gt; m = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">final</span> ReadWriteLock rwl = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">    <span class="keyword">final</span> Lock r = rwl.readLock();</span><br><span class="line">    <span class="keyword">final</span> Lock w = rwl.writeLock();</span><br><span class="line"></span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">(K k)</span> </span>{</span><br><span class="line">        V v = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// read cache</span></span><br><span class="line">        r.lock();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            v = m.get(k);</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            r.unlock();</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// cache exist,return</span></span><br><span class="line">        <span class="keyword">if</span> (v != <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> v;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// cache doesn't exist,query database</span></span><br><span class="line">        w.lock();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// check again</span></span><br><span class="line">            <span class="comment">// other thread may already query database</span></span><br><span class="line">            v = m.get(k);</span><br><span class="line">            <span class="keyword">if</span> (v == <span class="keyword">null</span>) {</span><br><span class="line">                <span class="comment">// query database</span></span><br><span class="line">                v = v;</span><br><span class="line">                m.put(k, v);</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            w.unlock();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">processCachedData</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="comment">// earn read lock</span></span><br><span class="line">        r.lock();</span><br><span class="line">        <span class="keyword">if</span> (!cacheValid) {</span><br><span class="line">            <span class="comment">// release read lock because can't allow upgrade read lock</span></span><br><span class="line">            r.unlock();</span><br><span class="line">            <span class="comment">// earn write lock</span></span><br><span class="line">            w.lock();</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="comment">// check status again </span></span><br><span class="line">                <span class="keyword">if</span> (!cacheValid) {</span><br><span class="line">                    data = <span class="string">"1"</span>;</span><br><span class="line">                    cacheValid = <span class="keyword">true</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">// before release write lock,downgrade lock to read lock</span></span><br><span class="line">                <span class="comment">// downgrade is allow</span></span><br><span class="line">                r.lock();</span><br><span class="line">            } <span class="keyword">finally</span> {</span><br><span class="line">                w.unlock();</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// in this place,still own read lock</span></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// do something. use(data)</span></span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            r.unlock();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="课后思考-9"><a href="#课后思考-9" class="headerlink" title="课后思考"></a>课后思考</h3><p>有同学反映线上系统停止响应了，CPU 利用率很低，你怀疑有同学一不小心写出了读锁升级写锁<br>的方案，那你该如何验证自己的怀疑呢？</p>
<h2 id="18-StampedLock：有没有比读写锁更快的锁？"><a href="#18-StampedLock：有没有比读写锁更快的锁？" class="headerlink" title="18 | StampedLock：有没有比读写锁更快的锁？"></a>18 | StampedLock：有没有比读写锁更快的锁？</h2><h3 id="StampedLock-读模板："><a href="#StampedLock-读模板：" class="headerlink" title="StampedLock 读模板："></a>StampedLock 读模板：</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> StampedLock sl =</span><br><span class="line">                <span class="keyword">new</span> StampedLock();</span><br><span class="line">        <span class="comment">// 乐观读</span></span><br><span class="line">        <span class="keyword">long</span> stamp = sl.tryOptimisticRead();</span><br><span class="line">        <span class="comment">// 读⼊⽅法局部变量 ... </span></span><br><span class="line">        <span class="comment">// 校验 stamp</span></span><br><span class="line">        <span class="keyword">if</span> (!sl.validate(stamp)) {</span><br><span class="line">            <span class="comment">// 升级为悲观读锁</span></span><br><span class="line">            stamp = sl.readLock();</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="comment">// 读⼊⽅法局部变量 ... </span></span><br><span class="line">            } <span class="keyword">finally</span> {</span><br><span class="line">                <span class="comment">// 释放悲观读锁</span></span><br><span class="line">                sl.unlockRead(stamp);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 使⽤⽅法局部变量执⾏业务操作 .. </span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="StampedLock-写模板："><a href="#StampedLock-写模板：" class="headerlink" title="StampedLock 写模板："></a>StampedLock 写模板：</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> stamp = sl.writeLock();</span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line"><span class="comment">// 写共享变量 ......</span></span><br><span class="line"></span><br><span class="line">} <span class="keyword">finally</span> {</span><br><span class="line">    sl.unlockWrite(stamp);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="课后思考-10"><a href="#课后思考-10" class="headerlink" title="课后思考"></a>课后思考</h2><p>StampedLock 支持锁的降级（通过 tryConvertToReadLock() 方法实现）和升级（通过tryConvertToWriteLock() 方法实现），但是建议你要慎重使用。下面的代码也源自 Java 的官方示例，我仅仅做了一点修改，隐藏了一个 Bug，你来看看 Bug 出在哪里吧。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">double</span> x, y;</span><br><span class="line"><span class="keyword">final</span> StampedLock sl = <span class="keyword">new</span> StampedLock();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存在问题的⽅法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">moveIfAtOrigin</span><span class="params">(<span class="keyword">double</span> newX, <span class="keyword">double</span> newY)</span> </span>{</span><br><span class="line">    <span class="keyword">long</span> stamp = sl.readLock();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">while</span> (x == <span class="number">0.0</span> &amp;&amp; y == <span class="number">0.0</span>) {</span><br><span class="line">            <span class="keyword">long</span> ws = sl.tryConvertToWriteLock(stamp);</span><br><span class="line">            <span class="keyword">if</span> (ws != <span class="number">0L</span>) {</span><br><span class="line">                <span class="comment">//问题出在没有对stamp重新赋值</span></span><br><span class="line"><span class="comment">//新增下⾯⼀⾏</span></span><br><span class="line">                stamp = ws;</span><br><span class="line">                x = newX;</span><br><span class="line">                y = newY;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                sl.unlockRead(stamp);</span><br><span class="line">                stamp = sl.writeLock();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        sl.unlock(stamp);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>bug是tryConvertToWriteLock返回的write stamp没有重新赋值给stamp</p>
<h2 id="19-CountDownLatch和CyclicBarrier：如何让多线程步调一致？"><a href="#19-CountDownLatch和CyclicBarrier：如何让多线程步调一致？" class="headerlink" title="19 | CountDownLatch和CyclicBarrier：如何让多线程步调一致？"></a>19 | CountDownLatch和CyclicBarrier：如何让多线程步调一致？</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CountDownLatch</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchTest</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) {</span><br><span class="line">            <span class="comment">// count init 2</span></span><br><span class="line">            CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">2</span>);</span><br><span class="line">            <span class="comment">// query 1</span></span><br><span class="line">            executorService.execute(() -&gt; {</span><br><span class="line">                <span class="comment">// do somethings</span></span><br><span class="line">                latch.countDown();</span><br><span class="line">            });</span><br><span class="line">            <span class="comment">// query 2</span></span><br><span class="line">            executorService.execute(() -&gt; {</span><br><span class="line">                latch.countDown();</span><br><span class="line">            });</span><br><span class="line"></span><br><span class="line">            latch.await();</span><br><span class="line">            <span class="keyword">boolean</span> check = check();</span><br><span class="line">            save();</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>{</span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="comment">// check something</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CyclicBarrier</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierTest</span> </span>{</span><br><span class="line">    <span class="comment">// queue 1</span></span><br><span class="line">    <span class="keyword">static</span> Vector&lt;String&gt; pos;</span><br><span class="line">    <span class="comment">// queue 2</span></span><br><span class="line">    <span class="keyword">static</span> Vector&lt;String&gt; dos;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// threadpool</span></span><br><span class="line">    <span class="keyword">static</span> Executor executor = Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>, () -&gt; {</span><br><span class="line">        executor.execute(() -&gt; check());</span><br><span class="line">    });</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">()</span> </span>{</span><br><span class="line">        String p = pos.remove(<span class="number">0</span>);</span><br><span class="line">        String d = dos.remove(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        check(p, d);</span><br><span class="line">        save();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>{</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">(String p, String d)</span> </span>{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">checkAll</span><span class="params">()</span> </span>{</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) {</span><br><span class="line">                <span class="comment">// exist </span></span><br><span class="line">                pos.add(<span class="string">""</span>);</span><br><span class="line">                <span class="comment">// </span></span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    barrier.await();</span><br><span class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                } <span class="keyword">catch</span> (BrokenBarrierException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">        t1.start();</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(() -&gt; {</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) {</span><br><span class="line">                <span class="comment">// exist </span></span><br><span class="line">                dos.add(<span class="string">""</span>);</span><br><span class="line">                <span class="comment">// </span></span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    barrier.await();</span><br><span class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                } <span class="keyword">catch</span> (BrokenBarrierException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>CyclicBarrier 的计数器有自动重置的功能，当减到 0 的时候，会自动重置你设置的初始值。</strong></p>
<h3 id="课后思考-11"><a href="#课后思考-11" class="headerlink" title="课后思考"></a>课后思考</h3><p><strong>本章最后的示例代码中，CyclicBarrier 的回调函数我们使用了一个固定大小的线程池，你觉得是否有必要呢？</strong></p>
<p>设置线程池为单个线程可以保证对账的操作按顺序执行</p>
<p>其实线程池改成多线程也可以，要把两个remove(0)放到一个同步块中</p>
<p>第二个是使用了线程池，如果不使用，直接在回调函数里调用check()方法是否可以呢？绝对不可以。为什么呢？这个要分析一下回调函数和唤醒等待线程之间的关系。下面是CyclicBarrier相关的源码，通过源码你会发现CyclicBarrier是同步调用回调函数之后才唤醒等待的线程，如果我们在回调函数里直接调用check()方<br>法，那就意味着在执行check()的时候，是不能同时执行getPOrders()和getDOrders()的，这样就起不到提升性能的作用。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> {</span><br><span class="line"><span class="comment">//barrierCommand是回调函数</span></span><br><span class="line"><span class="keyword">final</span> Runnable command = barrierCommand;</span><br><span class="line"><span class="comment">//调⽤回调函数</span></span><br><span class="line"><span class="keyword">if</span> (command != <span class="keyword">null</span>)</span><br><span class="line">command.run();</span><br><span class="line">ranAction = <span class="keyword">true</span>;</span><br><span class="line"><span class="comment">//唤醒等待的线程</span></span><br><span class="line">nextGeneration();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">} <span class="keyword">finally</span> {</span><br><span class="line"><span class="keyword">if</span> (!ranAction)</span><br><span class="line">breakBarrier();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>所以，当遇到回调函数的时候，你应该本能地问自己：执行回调函数的线程是哪一个？这个在多线程场景下非常重要。因为不同线程ThreadLocal里的数据是不同的，有些框架比如Spring就用ThreadLocal来管理事务，如果不清楚回调函数用的是哪个线程，很可能会导致错误的事务管理，并最终导致数据不一致。</p>
<p>CyclicBarrier的回调函数究竟是哪个线程执行的呢？如果你分析源码，你会发现执行回调函数的线程是将CyclicBarrier内部计数器减到 0 的那个线程。所以我们前面讲执行check()的时候，是不能同时执行getPOrders()和getDOrders()，因为执行这两个方法的线程一个在等待，一个正在忙着执行check()。</p>
<p><strong>再次强调一下：当看到回调函数的时候，一定问一问执行回调函数的线程是谁。</strong></p>
<h2 id="20-并发容器：都有哪些“坑”需要我们填？"><a href="#20-并发容器：都有哪些“坑”需要我们填？" class="headerlink" title="20 | 并发容器：都有哪些“坑”需要我们填？"></a>20 | 并发容器：都有哪些“坑”需要我们填？</h2><h3 id="（一）List"><a href="#（一）List" class="headerlink" title="（一）List"></a>（一）List</h3><p>CopyOnWriteArrayList</p>
<p>使用 CopyOnWriteArrayList 需要注意的“坑”主要有两个方面。一个是应用场景，<br>CopyOnWriteArrayList 仅适用于写操作非常少的场景，而且能够容忍读写的短暂不一致。写入的新元素并不能立刻被遍历到。另一个需要注意的是，CopyOnWriteArrayList迭代器是只读的，不支持增删改。因为迭代器遍历的仅仅是一个快照，而对快照进行增删改是没有意义的。</p>
<h3 id="（二）Map"><a href="#（二）Map" class="headerlink" title="（二）Map"></a>（二）Map</h3><p>ConcurrentHashMap 和 ConcurrentSkipListMap</p>
<p>ConcurrentHashMap 的 key 是无序的</p>
<p>ConcurrentSkipListMap 的 key 是有序的</p>
<p>使用 ConcurrentHashMap 和 ConcurrentSkipListMap 需要注意的地方是，它们的 key 和 value都不能为空，否则会抛出NullPointerException</p>
<p><img src="https://gitee.com/penno/blogimg/raw/master/img/20210914155458.png" alt="image-20210914155457963"></p>
<h3 id="（三）Set"><a href="#（三）Set" class="headerlink" title="（三）Set"></a>（三）Set</h3><p>CopyOnWriteArraySet 和 ConcurrentSkipListSet</p>
<h3 id="（四）Queue"><a href="#（四）Queue" class="headerlink" title="（四）Queue"></a>（四）Queue</h3><p>1.单端阻塞队列</p>
<p>ArrayBlockingQueue、LinkedBlockingQueue、SynchronousQueue、LinkedTransferQueue、PriorityBlockingQueue 和 DelayQueue。</p>
<p>2.双端阻塞队列：其实现是 LinkedBlockingDeque。</p>
<p>3.单端非阻塞队列：其实现是 ConcurrentLinkedQueue。</p>
<p>4.双端非阻塞队列：其实现是 ConcurrentLinkedDeque。</p>
<p>需要格外注意队列是否支持有界</p>
<p><strong>在使用其他无界队列时，一定要充分考虑是否存在导致 OOM 的隐患。</strong></p>
<h3 id="课后思考-12"><a href="#课后思考-12" class="headerlink" title="课后思考"></a>课后思考</h3><p>线上系统 CPU 突然飙升，你怀疑有同学在并发场景里使用了 HashMap，因为在 1.8 之前的版本里并发执行 HashMap.put() 可能会导致 CPU 飙升到 100%，你觉得该如何验证你的猜测呢？</p>
<p><strong>Java7中的HashMap在执行put操作时会涉及到扩容，由于扩容时链表并发操作会造成链表成环，所以可能导致cpu飙升100%。</strong></p>
<h2 id="21-原子类：无锁工具类的典范"><a href="#21-原子类：无锁工具类的典范" class="headerlink" title="21 | 原子类：无锁工具类的典范"></a>21 | 原子类：无锁工具类的典范</h2><p>无锁方案的实现原理</p>
<p>其实原子类性能高的秘密很简单，硬件支持而已。CPU 为了解决并发问题，提供了 CAS 指令（CAS，全称是 Compare And Swap，即“比较并交换”）。CAS 指令包含 3 个参数：共享变量的内存地址 A、用于比较的值 B 和共享变量的新值 C；并且只有当内存中地址 A 处的值等于 B时，才能将内存中地址 A 处的值更新为新值 C。作为一条 CPU 指令，CAS 指令本身是能够保证原子性的。</p>
<h3 id="1-原子化的基本数据类型"><a href="#1-原子化的基本数据类型" class="headerlink" title="1. 原子化的基本数据类型"></a>1. 原子化的基本数据类型</h3><h3 id="2-原子化的对象引用类型"><a href="#2-原子化的对象引用类型" class="headerlink" title="2. 原子化的对象引用类型"></a>2. 原子化的对象引用类型</h3><p>不过需要注意的是，对象引用的更新需要重点关注 ABA 问题，AtomicStampedReference 和 AtomicMarkableReference 这两个原子类可以解决 ABA 问题。</p>
<h3 id="3-原子化数组"><a href="#3-原子化数组" class="headerlink" title="3. 原子化数组"></a>3. 原子化数组</h3><h3 id="4-原子化对象属性更新器"><a href="#4-原子化对象属性更新器" class="headerlink" title="4. 原子化对象属性更新器"></a>4. 原子化对象属性更新器</h3><h3 id="5-原子化的累加器"><a href="#5-原子化的累加器" class="headerlink" title="5. 原子化的累加器"></a>5. 原子化的累加器</h3><h3 id="课后思考-13"><a href="#课后思考-13" class="headerlink" title="课后思考"></a>课后思考</h3><p><strong>下面的示例代码是合理库存的原子化实现，仅实现了设置库存上限 setUpper() 方法，你觉得setUpper() 方法的实现是否正确呢？</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SafeWM</span> </span>{</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">WMRange</span> </span>{</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> upper;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> lower;</span><br><span class="line"></span><br><span class="line">        WMRange(<span class="keyword">int</span> upper, <span class="keyword">int</span> lower) {</span><br><span class="line">        <span class="comment">// 省略构造函数实现</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> AtomicReference&lt;WMRange&gt;</span><br><span class="line">            rf = <span class="keyword">new</span> AtomicReference&lt;&gt;(</span><br><span class="line">            <span class="keyword">new</span> WMRange(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置库存上限</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setUpper</span><span class="params">(<span class="keyword">int</span> v)</span> </span>{</span><br><span class="line">        WMRange nr;</span><br><span class="line">        WMRange or = rf.get();</span><br><span class="line">        <span class="keyword">do</span> {</span><br><span class="line">            <span class="comment">// 检查参数合法性</span></span><br><span class="line">            <span class="keyword">if</span> (v &lt; or.lower) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">            }</span><br><span class="line">            nr = <span class="keyword">new</span></span><br><span class="line">                    WMRange(v, or.lower);</span><br><span class="line">        } <span class="keyword">while</span> (!rf.compareAndSet(or, nr));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>or是原始的 nr是new出来的 指向不同的内存地址 compareandset的结果永远返回false 结果是死循环？</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SafeWM</span> </span>{</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WMRange</span></span>{</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> upper;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> lower;</span><br><span class="line">WMRange(<span class="keyword">int</span> upper,<span class="keyword">int</span> lower){</span><br><span class="line"><span class="comment">//省略构造函数实现</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">final</span> AtomicReference&lt;WMRange&gt;</span><br><span class="line">rf = <span class="keyword">new</span> AtomicReference&lt;&gt;(</span><br><span class="line"><span class="keyword">new</span> WMRange(<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">);</span><br><span class="line"><span class="comment">// 设置库存上限</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setUpper</span><span class="params">(<span class="keyword">int</span> v)</span></span>{</span><br><span class="line">WMRange nr;</span><br><span class="line">WMRange or;</span><br><span class="line"><span class="comment">//原代码在这⾥</span></span><br><span class="line"><span class="comment">//WMRange or=rf.get();</span></span><br><span class="line"><span class="keyword">do</span>{</span><br><span class="line"><span class="comment">//移动到此处</span></span><br><span class="line"><span class="comment">//每个回合都需要重新获取旧值</span></span><br><span class="line">or = rf.get();</span><br><span class="line"><span class="comment">// 检查参数合法性</span></span><br><span class="line"><span class="keyword">if</span>(v &lt; or.lower){</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">}</span><br><span class="line">nr = <span class="keyword">new</span></span><br><span class="line">WMRange(v, or.lower);</span><br><span class="line">}<span class="keyword">while</span>(!rf.compareAndSet(or, nr));</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h2 id="22-Executor与线程池：如何创建正确的线程池？"><a href="#22-Executor与线程池：如何创建正确的线程池？" class="headerlink" title="22-Executor与线程池：如何创建正确的线程池？"></a>22-Executor与线程池：如何创建正确的线程池？</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//简化的线程池，仅⽤来说明⼯作原理</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadPool</span> </span>{</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    BlockingQueue&lt;Runnable&gt; workQueue;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    List&lt;WorkerThread&gt; threads = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThreadPool</span><span class="params">(<span class="keyword">int</span> poolSize, BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; poolSize; i++) {</span><br><span class="line">            WorkerThread workerThread = <span class="keyword">new</span> WorkerThread();</span><br><span class="line">            workerThread.start();</span><br><span class="line">            threads.add(workerThread);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        workQueue.put(command);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// workthread</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">WorkerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>{</span><br><span class="line">        <span class="meta">@SneakyThrows</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) {</span><br><span class="line">                Runnable task = workQueue.take();</span><br><span class="line">                task.run();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        BlockingQueue&lt;Runnable&gt; workQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        MyThreadPool myThreadPool = <span class="keyword">new</span> MyThreadPool(<span class="number">10</span>, workQueue);</span><br><span class="line">        myThreadPool.execute(() -&gt; {</span><br><span class="line">            System.out.println(<span class="string">"fuck"</span>);</span><br><span class="line">        });</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="课后思考-14"><a href="#课后思考-14" class="headerlink" title="课后思考"></a>课后思考</h3><p>使用线程池，默认情况下创建的线程名字都类似pool-1-thread-2这样，没有业务含义。而很多情况下为了便于诊断问题，都需要给线程赋予一个有意义的名字，那你知道有哪些办法可以给线程池里的线程指定名字吗？</p>
<h2 id="23-Future：如何用多线程实现最优的“烧水泡茶”程序？"><a href="#23-Future：如何用多线程实现最优的“烧水泡茶”程序？" class="headerlink" title="23-Future：如何用多线程实现最优的“烧水泡茶”程序？"></a>23-Future：如何用多线程实现最优的“烧水泡茶”程序？</h2><p>那如何使用FutureTask呢？其实很简单，FutureTask实现了Runnable和Future接口，由于实现了Runnable接口，所以可以将FutureTask对象作为任务提交给ThreadPoolExecutor去执行，也可以直接被Thread执行；又因为实现了Future接口，所以也能用来获得任务的执行结果。下面的示例代码是将FutureTask对象提<br>交给ThreadPoolExecutor去执行。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaoCha</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>{</span><br><span class="line"><span class="comment">//        BasicConfigurator.configure();</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">name</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>{</span><br><span class="line">        FutureTask&lt;String&gt; ft2 = <span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> T2Task());</span><br><span class="line">        FutureTask&lt;String&gt; ft1 = <span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> T1Task(ft2));</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(ft1);</span><br><span class="line">        t1.start();</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(ft2);</span><br><span class="line">        t2.start();</span><br><span class="line">        log.info(<span class="string">"fuck"</span>);</span><br><span class="line">        log.info(ft1.get());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">T1Task</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>{</span><br><span class="line"></span><br><span class="line">        FutureTask&lt;String&gt; ft2;</span><br><span class="line"></span><br><span class="line">        T1Task(FutureTask&lt;String&gt; ft2) {</span><br><span class="line">            <span class="keyword">this</span>.ft2 = ft2;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">            log.info(<span class="string">"T2.洗水壶..."</span>);</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            log.info(<span class="string">"T2.烧开水..."</span>);</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 获取T2线程的茶叶</span></span><br><span class="line">            String tf = ft2.get();</span><br><span class="line"></span><br><span class="line">            log.info(<span class="string">"T1.拿到茶叶...{}"</span>, tf);</span><br><span class="line">            log.info(<span class="string">"T1 泡茶"</span>);</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"上茶"</span> + tf;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">T2Task</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>{</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">            log.info(<span class="string">"T2.洗茶壶..."</span>);</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            log.info(<span class="string">"T2.洗茶杯..."</span>);</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            log.info(<span class="string">"T2.拿茶叶..."</span>);</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"龙井"</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>课后思考<br>不久前听说小明要做一个询价应用，这个应用需要从三个电商询价，然后保存在自己的数据库里。核心示例代码如下所示，由于是串行的，所以性能很慢，你来试着优化一下吧。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向电商S1询价，并保存</span></span><br><span class="line">r1 = getPriceByS1();</span><br><span class="line">save(r1);</span><br><span class="line"><span class="comment">// 向电商S2询价，并保存</span></span><br><span class="line">r2 = getPriceByS2();</span><br><span class="line"><span class="comment">// 向电商S3询价，并保存</span></span><br><span class="line">r3 = getPriceByS3();</span><br></pre></td></tr></tbody></table></figure>

<p>现在是在主线程串行完成3个询价的任务，执行第一个任务，其它2个任务只能等待执行，如果要提高效率，这个地方需要改进，可以用老师今天讲的futuretask，三个询价任务改成futuretask并行执行，效率会提高</p>
<h2 id="24-CompletableFuture：异步编程没那么难"><a href="#24-CompletableFuture：异步编程没那么难" class="headerlink" title="24-CompletableFuture：异步编程没那么难"></a>24-CompletableFuture：异步编程没那么难</h2><p>CompletableFuture的核心优势 </p>
<p>分工、协作和互斥</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaoCha</span> </span>{</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Test1</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="comment">// task 1 spoil</span></span><br><span class="line">        CompletableFuture&lt;Void&gt; f1 = CompletableFuture.runAsync(() -&gt; {</span><br><span class="line">            log.info(<span class="string">"T2.洗水壶..."</span>);</span><br><span class="line">            sleep(<span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">            log.info(<span class="string">"T2.烧开水..."</span>);</span><br><span class="line">            sleep(<span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">        });</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// task 2 get tea</span></span><br><span class="line">        CompletableFuture&lt;String&gt; f2 = CompletableFuture.supplyAsync(() -&gt; {</span><br><span class="line">            log.info(<span class="string">"T2.洗茶壶..."</span>);</span><br><span class="line">            sleep(<span class="number">1</span>,TimeUnit.SECONDS);</span><br><span class="line">            log.info(<span class="string">"T2.洗茶杯..."</span>);</span><br><span class="line">            sleep(<span class="number">1</span>,TimeUnit.SECONDS);</span><br><span class="line">            log.info(<span class="string">"T2.拿茶叶..."</span>);</span><br><span class="line">            sleep(<span class="number">1</span>,TimeUnit.SECONDS);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"龙井"</span>;</span><br><span class="line">        });</span><br><span class="line">        <span class="comment">// task 3 after 1 and 2 spoil tea</span></span><br><span class="line">        CompletableFuture&lt;String&gt; f3 = f1.thenCombine(f2, (unused, tf) -&gt; {</span><br><span class="line">            log.info(<span class="string">"T1,拿到茶叶{}"</span>, tf);</span><br><span class="line">            log.info(<span class="string">"T1.泡茶"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"上茶:"</span> + tf;</span><br><span class="line">        });</span><br><span class="line">        </span><br><span class="line">        log.info(f3.join());</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">int</span> t, TimeUnit u)</span> </span>{</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            u.sleep(t);</span><br><span class="line">        }<span class="keyword">catch</span>(InterruptedException e){}</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>根据不同的业务类型创建不同的线程池，以避免互相干扰。</strong></p>
<h3 id="如何理解CompletionStage接口"><a href="#如何理解CompletionStage接口" class="headerlink" title="如何理解CompletionStage接口"></a>如何理解CompletionStage接口</h3><h4 id="1-描述串行关系"><a href="#1-描述串行关系" class="headerlink" title="1. 描述串行关系"></a>1. 描述串行关系</h4><p>thenApply、thenAccept、thenRun和thenCompose</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Test2</span><span class="params">()</span> </span>{</span><br><span class="line">    CompletableFuture&lt;String&gt; f0 = CompletableFuture.supplyAsync(() -&gt; {</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"Hello World"</span>;</span><br><span class="line">            })</span><br><span class="line">            .thenApply(s -&gt; s + <span class="string">"QQ"</span>)</span><br><span class="line">            .thenApply(String::toUpperCase);</span><br><span class="line">    log.info(f0.join());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="2-描述AND汇聚关系"><a href="#2-描述AND汇聚关系" class="headerlink" title="2. 描述AND汇聚关系"></a>2. 描述AND汇聚关系</h4><h4 id="3-描述OR汇聚关系"><a href="#3-描述OR汇聚关系" class="headerlink" title="3. 描述OR汇聚关系"></a>3. 描述OR汇聚关系</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Test3</span><span class="params">()</span> </span>{</span><br><span class="line">    CompletableFuture&lt;String&gt; f1 = CompletableFuture.supplyAsync(() -&gt; {</span><br><span class="line">        <span class="keyword">int</span> t = getRandom(<span class="number">5</span>, <span class="number">10</span>);</span><br><span class="line">        sleep(t, TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(t);</span><br><span class="line">    });</span><br><span class="line"></span><br><span class="line">    CompletableFuture&lt;String&gt; f2 = CompletableFuture.supplyAsync(() -&gt; {</span><br><span class="line">        <span class="keyword">int</span> t = getRandom(<span class="number">5</span>, <span class="number">10</span>);</span><br><span class="line">        sleep(t, TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(t);</span><br><span class="line">    });</span><br><span class="line"></span><br><span class="line">    CompletableFuture&lt;String&gt; f3 = f1.applyToEither(f2, s -&gt; s);</span><br><span class="line"></span><br><span class="line">    log.info(f3.join());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getRandom</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> i1)</span> </span>{</span><br><span class="line">    ThreadLocalRandom random1 = RandomUtil.getRandom();</span><br><span class="line">    <span class="keyword">return</span> random1.nextInt(i, i1);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="4-异常处理"><a href="#4-异常处理" class="headerlink" title="4. 异常处理"></a>4. 异常处理</h4><h3 id="课后思考-15"><a href="#课后思考-15" class="headerlink" title="课后思考"></a>课后思考</h3><p>创建采购订单的时候，需要校验一些规则，例如最大金额是和采购员级别相关的。有同学利用CompletableFuture实现了这个校验的功能，逻辑很简单，首先是从数据库中把相关规则查出来，然后执行规则校验。你觉得他的实现是否有问题呢？</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//采购订单</span></span><br><span class="line">PurchersOrder po;</span><br><span class="line">CompletableFuture&lt;Boolean&gt; cf =</span><br><span class="line">CompletableFuture.supplyAsync(()-&gt;{</span><br><span class="line"><span class="comment">//在数据库中查询规则</span></span><br><span class="line"><span class="keyword">return</span> findRuleByJdbc();</span><br><span class="line">}).thenApply(r -&gt; {</span><br><span class="line"><span class="comment">//规则校验</span></span><br><span class="line"><span class="keyword">return</span> check(po, r);</span><br><span class="line">});</span><br><span class="line">Boolean isOk = cf.join();</span><br></pre></td></tr></tbody></table></figure>

<p>findRuleByJdbc()这个方法<br>隐藏着一个阻塞式I/O，这意味着会阻塞调用线程。默认情况下所有的CompletableFuture共享一个<br>ForkJoinPool，当有阻塞式I/O时，可能导致所有的ForkJoinPool线程都阻塞，进而影响整个系统的性能。</p>
<p>利用共享，往往能让我们快速实现功能，所谓是有福同享，但是代价就是有难要同当。在强调高可用的今<br>天，大多数人更倾向于使用隔离的方案。</p>
<h2 id="25-CompletionService：如何批量执行异步任务？"><a href="#25-CompletionService：如何批量执行异步任务？" class="headerlink" title="25-CompletionService：如何批量执行异步任务？"></a>25-CompletionService：如何批量执行异步任务？</h2><h3 id="课后思考-16"><a href="#课后思考-16" class="headerlink" title="课后思考"></a>课后思考</h3><p>本章使用CompletionService实现了一个询价应用的核心功能，后来又有了新的需求，需要计算出最低报价<br>并返回，下面的示例代码尝试实现这个需求，你看看是否存在问题呢？</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建线程池</span></span><br><span class="line">ExecutorService executor =</span><br><span class="line">Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// 创建CompletionService</span></span><br><span class="line">CompletionService&lt;Integer&gt; cs = <span class="keyword">new</span></span><br><span class="line">ExecutorCompletionService&lt;&gt;(executor);</span><br><span class="line"><span class="comment">// 异步向电商S1询价</span></span><br><span class="line">cs.submit(()-&gt;getPriceByS1());</span><br><span class="line"><span class="comment">// 异步向电商S2询价</span></span><br><span class="line">cs.submit(()-&gt;getPriceByS2());</span><br><span class="line"><span class="comment">// 异步向电商S3询价</span></span><br><span class="line">cs.submit(()-&gt;getPriceByS3());</span><br><span class="line"><span class="comment">// 将询价结果异步保存到数据库</span></span><br><span class="line"><span class="comment">// 并计算最低报价</span></span><br><span class="line">AtomicReference&lt;Integer&gt; m =</span><br><span class="line"><span class="keyword">new</span> AtomicReference&lt;&gt;(Integer.MAX_VALUE);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++) {</span><br><span class="line">executor.execute(()-&gt;{</span><br><span class="line">Integer r = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">r = cs.take().get();</span><br><span class="line">} <span class="keyword">catch</span> (Exception e) {}</span><br><span class="line">save(r);</span><br><span class="line">m.set(Integer.min(m.get(), r));</span><br><span class="line">});</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> m;</span><br></pre></td></tr></tbody></table></figure>

<p>1.AtomicReference<integer>的get方法应该改成使用cas方法</integer></p>
<p>2.最后筛选最小结果的任务是异步执行的，应该在return之前做同步，所以最好使用sumit提交该任务便<br>于判断任务的完成</p>
<h2 id="26-ForkJoin：单机版的MapReduce"><a href="#26-ForkJoin：单机版的MapReduce" class="headerlink" title="26-ForkJoin：单机版的MapReduce"></a>26-ForkJoin：单机版的MapReduce</h2><p>对于简单的并行任务，你可以通过“线程池+Future”的方案来解决；如果任务之间有聚合关系，无论是AND聚合还是OR聚合，都可以通过CompletableFuture来解决；而批量的并行任务，则可以通过CompletionService来解决。</p>
<h3 id="分治任务模型"><a href="#分治任务模型" class="headerlink" title="分治任务模型"></a>分治任务模型</h3><h3 id="Fork-Join的使用"><a href="#Fork-Join的使用" class="headerlink" title="Fork/Join的使用"></a>Fork/Join的使用</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinTest</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="comment">// create Divide and conquer task thread pool</span></span><br><span class="line">        ForkJoinPool fjp = <span class="keyword">new</span> ForkJoinPool(<span class="number">4</span>);</span><br><span class="line">        <span class="comment">// create Divide and conquer task</span></span><br><span class="line">        Fibonacci fib = <span class="keyword">new</span> Fibonacci(<span class="number">30</span>);</span><br><span class="line">        <span class="comment">// start task</span></span><br><span class="line">        Integer result = fjp.invoke(fib);</span><br><span class="line">        log.info(String.valueOf(result));</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Fibonacci</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt; </span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">            <span class="keyword">this</span>.n = n;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) {</span><br><span class="line">                <span class="keyword">return</span> n;</span><br><span class="line">            }</span><br><span class="line">            Fibonacci f1 = <span class="keyword">new</span> Fibonacci(n - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// create child task</span></span><br><span class="line">            f1.fork();</span><br><span class="line">            Fibonacci f2 = <span class="keyword">new</span> Fibonacci(n - <span class="number">2</span>);</span><br><span class="line">            <span class="comment">// wait the result of child task ,and combine result</span></span><br><span class="line">            <span class="keyword">return</span> f2.compute() + f1.join();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="模拟MapReduce统计单词数量"><a href="#模拟MapReduce统计单词数量" class="headerlink" title="模拟MapReduce统计单词数量"></a>模拟MapReduce统计单词数量</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountWord</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        String[] fc = {<span class="string">"hello world"</span>,</span><br><span class="line">                <span class="string">"hello me"</span>,</span><br><span class="line">                <span class="string">"hello fork"</span>,</span><br><span class="line">                <span class="string">"hello join"</span>,</span><br><span class="line">                <span class="string">"fork join in world"</span>};</span><br><span class="line">        <span class="comment">// create fork join thread pool </span></span><br><span class="line">        ForkJoinPool fjp = <span class="keyword">new</span> ForkJoinPool(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">// create task</span></span><br><span class="line">        MR mr = <span class="keyword">new</span> MR(fc, <span class="number">0</span>, fc.length);</span><br><span class="line">        <span class="comment">// start task</span></span><br><span class="line">        Map&lt;String, Long&gt; result = fjp.invoke(mr);</span><br><span class="line">        <span class="comment">// sout result</span></span><br><span class="line">        result.forEach((k, v) -&gt; {</span><br><span class="line">            log.info(<span class="string">"{}:{}"</span>,k, v);</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MR</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Map</span>&lt;<span class="title">String</span>, <span class="title">Long</span>&gt;&gt; </span>{</span><br><span class="line">        <span class="keyword">private</span> String[] fc;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> start, end;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MR</span><span class="params">(String[] fc, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>{</span><br><span class="line">            <span class="keyword">this</span>.fc = fc;</span><br><span class="line">            <span class="keyword">this</span>.start = start;</span><br><span class="line">            <span class="keyword">this</span>.end = end;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Map&lt;String, Long&gt; <span class="title">compute</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">if</span> (end - start == <span class="number">1</span>) {</span><br><span class="line">                <span class="keyword">return</span> calc(fc[start]);</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">int</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">                MR mr1 = <span class="keyword">new</span> MR(fc, start, mid);</span><br><span class="line">                mr1.fork();</span><br><span class="line">                MR mr2 = <span class="keyword">new</span> MR(fc, mid, end);</span><br><span class="line">                <span class="comment">// compute child task and return combine count</span></span><br><span class="line">                <span class="keyword">return</span> merge(mr2.compute(), mr1.join());</span><br><span class="line"></span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> Map&lt;String, Long&gt; <span class="title">merge</span><span class="params">(Map&lt;String, Long&gt; r1, Map&lt;String, Long&gt; r2)</span> </span>{</span><br><span class="line">            Map&lt;String, Long&gt; result = <span class="keyword">new</span> HashMap&lt;&gt;(r1);</span><br><span class="line">            <span class="comment">// merge result</span></span><br><span class="line">            r2.forEach((k, v) -&gt; result.merge(k, v, Long::sum));</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> Map&lt;String, Long&gt; <span class="title">calc</span><span class="params">(String line)</span> </span>{</span><br><span class="line">            Map&lt;String, Long&gt; result = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            <span class="comment">// divide word</span></span><br><span class="line">            String[] words = line.split(<span class="string">"\\s+"</span>);</span><br><span class="line">            <span class="comment">// count words</span></span><br><span class="line">            <span class="keyword">for</span> (String word : words) {</span><br><span class="line">                Long v = result.get(word);</span><br><span class="line">                <span class="keyword">if</span> (v != <span class="keyword">null</span>) {</span><br><span class="line">                    result.put(word, v + <span class="number">1</span>);</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    result.put(word, <span class="number">1L</span>);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Fork/Join并行计算框架主要解决的是分治任务。分治的核心思想是“分而治之”：将一个大的任务拆分成小的子任务去解决，然后再把子任务的结果聚合起来从而得到最终结果。这个过程非常类似于大数据处理中的MapReduce，所以你可以把Fork/Join看作单机版的MapReduce。</p>
<p>Fork/Join并行计算框架的核心组件是ForkJoinPool。ForkJoinPool支持任务窃取机制，能够让所有线程的工作量基本均衡，不会出现有的线程很忙，而有的线程很闲的状况，所以性能很好。Java 1.8提供的StreamAPI里面并行流也是以ForkJoinPool为基础的。不过需要你注意的是，默认情况下所有的并行流计算都共享一个ForkJoinPool，这个共享的ForkJoinPool默认的线程数是CPU的核数；如果所有的并行流计算都是CPU密集型计算的话，完全没有问题，但是如果存在I/O密集型的并行流计算，那么很可能会因为一个很慢的I/O计算而拖慢整个系统的性能。所以建议用不同的ForkJoinPool执行不同类型的计算任务。</p>
<h2 id="27-并发工具类模块热点问题答疑"><a href="#27-并发工具类模块热点问题答疑" class="headerlink" title="27-并发工具类模块热点问题答疑"></a>27-并发工具类模块热点问题答疑</h2></div><div class="article-licensing box"><div class="licensing-title"><p>Java并发编程实战</p><p><a href="https://zeroornull.github.io/2021/09/15/Java并发编程实战/">https://zeroornull.github.io/2021/09/15/Java并发编程实战/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>Zeroornull</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2021-09-15</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2021-09-15</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Java%E5%B9%B6%E5%8F%91/">Java并发</a></div><div class="sharethis-inline-share-buttons"></div><script src="https://platform-api.sharethis.com/js/sharethis.js#property=60667abe39329f00123aea68&amp;product=sticky-share-buttons" defer></script></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" href="https://www.afdian.net/@zeroornull" target="_blank" rel="noopener" data-type="afdian"><span class="icon is-small"><i class="fas fa-charging-station"></i></span><span>爱发电</span></a><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="https://qr.alipay.com/fkx00721flijbw5hdn0kab5" alt="支付宝"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2021/08/15/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98_%E6%A0%B8%E5%BF%83%E7%AF%87_%E7%AC%94%E8%AE%B0/"><span class="level-item">Java并发编程实战_核心篇笔记</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="https://z3.ax1x.com/2021/07/27/WhycSH.gif" alt="Zeroornull"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Zeroornull</p><p class="is-size-6 is-block">just one newbie</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>ShangHai</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">21</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">15</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">15</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/zeroornull" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/zeroornull"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="SinaBlog" href="https://weibo.com/u/3027767592"><i class="fa-brands fa-weibo"></i></a></div></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#前言"><span class="level-left"><span class="level-item">1</span><span class="level-item">前言</span></span></a></li><li><a class="level is-mobile" href="#Java并发编程实战"><span class="level-left"><span class="level-item">2</span><span class="level-item">Java并发编程实战</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#01-可见性、原子性和有序性问题：并发编程Bug的源头"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">01 | 可见性、原子性和有序性问题：并发编程Bug的源头</span></span></a></li><li><a class="level is-mobile" href="#02-Java内存模型：看Java如何解决可见性和有序性问题"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">02 | Java内存模型：看Java如何解决可见性和有序性问题</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Happens-Before-规则"><span class="level-left"><span class="level-item">2.2.1</span><span class="level-item">Happens-Before 规则</span></span></a></li></ul></li><li><a class="level is-mobile" href="#03-互斥锁（上）：解决原子性问题"><span class="level-left"><span class="level-item">2.3</span><span class="level-item">03 | 互斥锁（上）：解决原子性问题</span></span></a></li><li><a class="level is-mobile" href="#04-互斥锁（下）：如何用一把锁保护多个资源？"><span class="level-left"><span class="level-item">2.4</span><span class="level-item">04 | 互斥锁（下）：如何用一把锁保护多个资源？</span></span></a></li><li><a class="level is-mobile" href="#05-一不小心就死锁了，怎么办？"><span class="level-left"><span class="level-item">2.5</span><span class="level-item">05 | 一不小心就死锁了，怎么办？</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#如何预防死锁"><span class="level-left"><span class="level-item">2.5.1</span><span class="level-item">如何预防死锁</span></span></a></li><li><a class="level is-mobile" href="#1-破坏占用且等待条件"><span class="level-left"><span class="level-item">2.5.2</span><span class="level-item">1. 破坏占用且等待条件</span></span></a></li><li><a class="level is-mobile" href="#2-破坏不可抢占条件"><span class="level-left"><span class="level-item">2.5.3</span><span class="level-item">2. 破坏不可抢占条件</span></span></a></li><li><a class="level is-mobile" href="#3-破坏循环等待条件"><span class="level-left"><span class="level-item">2.5.4</span><span class="level-item">3. 破坏循环等待条件</span></span></a></li><li><a class="level is-mobile" href="#课后题"><span class="level-left"><span class="level-item">2.5.5</span><span class="level-item">课后题</span></span></a></li></ul></li><li><a class="level is-mobile" href="#06-用“等待-通知”机制优化循环等待"><span class="level-left"><span class="level-item">2.6</span><span class="level-item">06 | 用“等待-通知”机制优化循环等待</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#一个更好地资源分配器"><span class="level-left"><span class="level-item">2.6.1</span><span class="level-item">一个更好地资源分配器</span></span></a></li><li><a class="level is-mobile" href="#尽量使用-notifyAll"><span class="level-left"><span class="level-item">2.6.2</span><span class="level-item">尽量使用 notifyAll()</span></span></a></li><li><a class="level is-mobile" href="#课后题-1"><span class="level-left"><span class="level-item">2.6.3</span><span class="level-item">课后题</span></span></a></li></ul></li><li><a class="level is-mobile" href="#07-安全性、活跃性以及性能问题"><span class="level-left"><span class="level-item">2.7</span><span class="level-item">07 | 安全性、活跃性以及性能问题</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#课后思考"><span class="level-left"><span class="level-item">2.7.1</span><span class="level-item">课后思考</span></span></a></li></ul></li><li><a class="level is-mobile" href="#08-管程：并发编程的万能钥匙"><span class="level-left"><span class="level-item">2.8</span><span class="level-item">08 | 管程：并发编程的万能钥匙</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#课后思考-1"><span class="level-left"><span class="level-item">2.8.1</span><span class="level-item">课后思考</span></span></a></li></ul></li><li><a class="level is-mobile" href="#09-Java线程（上）：Java线程的生命周期"><span class="level-left"><span class="level-item">2.9</span><span class="level-item">09 | Java线程（上）：Java线程的生命周期</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#课后思考-2"><span class="level-left"><span class="level-item">2.9.1</span><span class="level-item">课后思考</span></span></a></li></ul></li><li><a class="level is-mobile" href="#10-Java线程（中）：创建多少线程才是合适的？"><span class="level-left"><span class="level-item">2.10</span><span class="level-item">10 | Java线程（中）：创建多少线程才是合适的？</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#课后思考-3"><span class="level-left"><span class="level-item">2.10.1</span><span class="level-item">课后思考</span></span></a></li></ul></li><li><a class="level is-mobile" href="#11-Java线程（下）：为什么局部变量是线程安全的？"><span class="level-left"><span class="level-item">2.11</span><span class="level-item">11| Java线程（下）：为什么局部变量是线程安全的？</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#课后思考-4"><span class="level-left"><span class="level-item">2.11.1</span><span class="level-item">课后思考</span></span></a></li></ul></li><li><a class="level is-mobile" href="#12-如何用面向对象思想写好并发程序？"><span class="level-left"><span class="level-item">2.12</span><span class="level-item">12 | 如何用面向对象思想写好并发程序？</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#一、封装共享变量"><span class="level-left"><span class="level-item">2.12.1</span><span class="level-item">一、封装共享变量</span></span></a></li><li><a class="level is-mobile" href="#二、识别共享变量间的约束条件"><span class="level-left"><span class="level-item">2.12.2</span><span class="level-item">二、识别共享变量间的约束条件</span></span></a></li><li><a class="level is-mobile" href="#三、制定并发访问策略"><span class="level-left"><span class="level-item">2.12.3</span><span class="level-item">三、制定并发访问策略</span></span></a></li><li><a class="level is-mobile" href="#课后思考-5"><span class="level-left"><span class="level-item">2.12.4</span><span class="level-item">课后思考</span></span></a></li></ul></li><li><a class="level is-mobile" href="#13-理论基础模块热点问题答疑"><span class="level-left"><span class="level-item">2.13</span><span class="level-item">13 | 理论基础模块热点问题答疑</span></span></a></li><li><a class="level is-mobile" href="#14-Lock-amp-Condition（上）：隐藏在并发包中的管程"><span class="level-left"><span class="level-item">2.14</span><span class="level-item">14 | Lock&amp;Condition（上）：隐藏在并发包中的管程</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#什么是可重入锁"><span class="level-left"><span class="level-item">2.14.1</span><span class="level-item">什么是可重入锁</span></span></a></li><li><a class="level is-mobile" href="#用锁的最佳实践"><span class="level-left"><span class="level-item">2.14.2</span><span class="level-item">用锁的最佳实践</span></span></a></li><li><a class="level is-mobile" href="#课后思考-6"><span class="level-left"><span class="level-item">2.14.3</span><span class="level-item">课后思考</span></span></a></li></ul></li><li><a class="level is-mobile" href="#15-Lock和Condition（下）：Dubbo如何用管程实现异步转同步？"><span class="level-left"><span class="level-item">2.15</span><span class="level-item">15 | Lock和Condition（下）：Dubbo如何用管程实现异步转同步？</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#课后思考-7"><span class="level-left"><span class="level-item">2.15.1</span><span class="level-item">课后思考</span></span></a></li></ul></li><li><a class="level is-mobile" href="#16-Semaphore：如何快速实现一个限流器？"><span class="level-left"><span class="level-item">2.16</span><span class="level-item">16 | Semaphore：如何快速实现一个限流器？</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#课后思考-8"><span class="level-left"><span class="level-item">2.16.1</span><span class="level-item">课后思考</span></span></a></li></ul></li><li><a class="level is-mobile" href="#17-ReadWriteLock：如何快速实现一个完备的缓存？"><span class="level-left"><span class="level-item">2.17</span><span class="level-item">17 | ReadWriteLock：如何快速实现一个完备的缓存？</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#课后思考-9"><span class="level-left"><span class="level-item">2.17.1</span><span class="level-item">课后思考</span></span></a></li></ul></li><li><a class="level is-mobile" href="#18-StampedLock：有没有比读写锁更快的锁？"><span class="level-left"><span class="level-item">2.18</span><span class="level-item">18 | StampedLock：有没有比读写锁更快的锁？</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#StampedLock-读模板："><span class="level-left"><span class="level-item">2.18.1</span><span class="level-item">StampedLock 读模板：</span></span></a></li><li><a class="level is-mobile" href="#StampedLock-写模板："><span class="level-left"><span class="level-item">2.18.2</span><span class="level-item">StampedLock 写模板：</span></span></a></li></ul></li><li><a class="level is-mobile" href="#课后思考-10"><span class="level-left"><span class="level-item">2.19</span><span class="level-item">课后思考</span></span></a></li><li><a class="level is-mobile" href="#19-CountDownLatch和CyclicBarrier：如何让多线程步调一致？"><span class="level-left"><span class="level-item">2.20</span><span class="level-item">19 | CountDownLatch和CyclicBarrier：如何让多线程步调一致？</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#课后思考-11"><span class="level-left"><span class="level-item">2.20.1</span><span class="level-item">课后思考</span></span></a></li></ul></li><li><a class="level is-mobile" href="#20-并发容器：都有哪些“坑”需要我们填？"><span class="level-left"><span class="level-item">2.21</span><span class="level-item">20 | 并发容器：都有哪些“坑”需要我们填？</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#（一）List"><span class="level-left"><span class="level-item">2.21.1</span><span class="level-item">（一）List</span></span></a></li><li><a class="level is-mobile" href="#（二）Map"><span class="level-left"><span class="level-item">2.21.2</span><span class="level-item">（二）Map</span></span></a></li><li><a class="level is-mobile" href="#（三）Set"><span class="level-left"><span class="level-item">2.21.3</span><span class="level-item">（三）Set</span></span></a></li><li><a class="level is-mobile" href="#（四）Queue"><span class="level-left"><span class="level-item">2.21.4</span><span class="level-item">（四）Queue</span></span></a></li><li><a class="level is-mobile" href="#课后思考-12"><span class="level-left"><span class="level-item">2.21.5</span><span class="level-item">课后思考</span></span></a></li></ul></li><li><a class="level is-mobile" href="#21-原子类：无锁工具类的典范"><span class="level-left"><span class="level-item">2.22</span><span class="level-item">21 | 原子类：无锁工具类的典范</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#1-原子化的基本数据类型"><span class="level-left"><span class="level-item">2.22.1</span><span class="level-item">1. 原子化的基本数据类型</span></span></a></li><li><a class="level is-mobile" href="#2-原子化的对象引用类型"><span class="level-left"><span class="level-item">2.22.2</span><span class="level-item">2. 原子化的对象引用类型</span></span></a></li><li><a class="level is-mobile" href="#3-原子化数组"><span class="level-left"><span class="level-item">2.22.3</span><span class="level-item">3. 原子化数组</span></span></a></li><li><a class="level is-mobile" href="#4-原子化对象属性更新器"><span class="level-left"><span class="level-item">2.22.4</span><span class="level-item">4. 原子化对象属性更新器</span></span></a></li><li><a class="level is-mobile" href="#5-原子化的累加器"><span class="level-left"><span class="level-item">2.22.5</span><span class="level-item">5. 原子化的累加器</span></span></a></li><li><a class="level is-mobile" href="#课后思考-13"><span class="level-left"><span class="level-item">2.22.6</span><span class="level-item">课后思考</span></span></a></li></ul></li><li><a class="level is-mobile" href="#22-Executor与线程池：如何创建正确的线程池？"><span class="level-left"><span class="level-item">2.23</span><span class="level-item">22-Executor与线程池：如何创建正确的线程池？</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#课后思考-14"><span class="level-left"><span class="level-item">2.23.1</span><span class="level-item">课后思考</span></span></a></li></ul></li><li><a class="level is-mobile" href="#23-Future：如何用多线程实现最优的“烧水泡茶”程序？"><span class="level-left"><span class="level-item">2.24</span><span class="level-item">23-Future：如何用多线程实现最优的“烧水泡茶”程序？</span></span></a></li><li><a class="level is-mobile" href="#24-CompletableFuture：异步编程没那么难"><span class="level-left"><span class="level-item">2.25</span><span class="level-item">24-CompletableFuture：异步编程没那么难</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#如何理解CompletionStage接口"><span class="level-left"><span class="level-item">2.25.1</span><span class="level-item">如何理解CompletionStage接口</span></span></a></li><li><a class="level is-mobile" href="#课后思考-15"><span class="level-left"><span class="level-item">2.25.2</span><span class="level-item">课后思考</span></span></a></li></ul></li><li><a class="level is-mobile" href="#25-CompletionService：如何批量执行异步任务？"><span class="level-left"><span class="level-item">2.26</span><span class="level-item">25-CompletionService：如何批量执行异步任务？</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#课后思考-16"><span class="level-left"><span class="level-item">2.26.1</span><span class="level-item">课后思考</span></span></a></li></ul></li><li><a class="level is-mobile" href="#26-ForkJoin：单机版的MapReduce"><span class="level-left"><span class="level-item">2.27</span><span class="level-item">26-ForkJoin：单机版的MapReduce</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#分治任务模型"><span class="level-left"><span class="level-item">2.27.1</span><span class="level-item">分治任务模型</span></span></a></li><li><a class="level is-mobile" href="#Fork-Join的使用"><span class="level-left"><span class="level-item">2.27.2</span><span class="level-item">Fork/Join的使用</span></span></a></li><li><a class="level is-mobile" href="#模拟MapReduce统计单词数量"><span class="level-left"><span class="level-item">2.27.3</span><span class="level-item">模拟MapReduce统计单词数量</span></span></a></li><li><a class="level is-mobile" href="#总结"><span class="level-left"><span class="level-item">2.27.4</span><span class="level-item">总结</span></span></a></li></ul></li><li><a class="level is-mobile" href="#27-并发工具类模块热点问题答疑"><span class="level-left"><span class="level-item">2.28</span><span class="level-item">27-并发工具类模块热点问题答疑</span></span></a></li></ul></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile" href="https://bulma.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bulma</span></span><span class="level-right"><span class="level-item tag">bulma.io</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/DeepLearning/"><span class="level-start"><span class="level-item">DeepLearning</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Java/"><span class="level-start"><span class="level-item">Java</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Java%E5%B9%B6%E5%8F%91/"><span class="level-start"><span class="level-item">Java并发</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/SpringCloud/"><span class="level-start"><span class="level-item">SpringCloud</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/db2/"><span class="level-start"><span class="level-item">db2</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/eladmin/"><span class="level-start"><span class="level-item">eladmin</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/es/"><span class="level-start"><span class="level-item">es</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/githubpage/"><span class="level-start"><span class="level-item">githubpage</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/linux/"><span class="level-start"><span class="level-item">linux</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/nginx/"><span class="level-start"><span class="level-item">nginx</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/redis/"><span class="level-start"><span class="level-item">redis</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/sql/"><span class="level-start"><span class="level-item">sql</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/vue/"><span class="level-start"><span class="level-item">vue</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%B0%8F%E5%AD%A6%E7%94%9F%E4%BD%9C%E6%96%87-%E6%88%91%E7%9A%84%E7%94%9F%E6%B4%BB/"><span class="level-start"><span class="level-item">小学生作文-我的生活</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%AE%97%E6%B3%95/"><span class="level-start"><span class="level-item">算法</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-09-15T05:18:05.000Z">2021-09-15</time></p><p class="title"><a href="/2021/09/15/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/">Java并发编程实战</a></p><p class="categories"><a href="/categories/Java%E5%B9%B6%E5%8F%91/">Java并发</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-08-15T01:28:25.000Z">2021-08-15</time></p><p class="title"><a href="/2021/08/15/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98_%E6%A0%B8%E5%BF%83%E7%AF%87_%E7%AC%94%E8%AE%B0/">Java并发编程实战_核心篇笔记</a></p><p class="categories"><a href="/categories/Java/">Java</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-08-13T00:28:25.000Z">2021-08-13</time></p><p class="title"><a href="/2021/08/13/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/">Java线程池学习总结</a></p><p class="categories"><a href="/categories/Java/">Java</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-08-03T15:40:07.000Z">2021-08-03</time></p><p class="title"><a href="/2021/08/03/%E8%B7%AF%E4%B8%8A%E7%9A%84%E7%8B%97%E5%AD%90/">路上的狗子</a></p><p class="categories"><a href="/categories/%E5%B0%8F%E5%AD%A6%E7%94%9F%E4%BD%9C%E6%96%87-%E6%88%91%E7%9A%84%E7%94%9F%E6%B4%BB/">小学生作文-我的生活</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-07-29T14:25:07.000Z">2021-07-29</time></p><p class="title"><a href="/2021/07/29/%E6%99%9A%E4%B8%8A10%E7%82%B9%E5%87%BA%E9%97%A8%E6%90%9E%E5%A4%9C%E5%AE%B5/">晚上10点出门搞夜宵</a></p><p class="categories"><a href="/categories/%E5%B0%8F%E5%AD%A6%E7%94%9F%E4%BD%9C%E6%96%87-%E6%88%91%E7%9A%84%E7%94%9F%E6%B4%BB/">小学生作文-我的生活</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2021/09/"><span class="level-start"><span class="level-item">九月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/08/"><span class="level-start"><span class="level-item">八月 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/07/"><span class="level-start"><span class="level-item">七月 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/06/"><span class="level-start"><span class="level-item">六月 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/05/"><span class="level-start"><span class="level-item">五月 2021</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/04/"><span class="level-start"><span class="level-item">四月 2021</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/10/"><span class="level-start"><span class="level-item">十月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/DeepLearning/"><span class="tag">DeepLearning</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Java/"><span class="tag">Java</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Java%E5%B9%B6%E5%8F%91/"><span class="tag">Java并发</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/SpringCloud/"><span class="tag">SpringCloud</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/db2/"><span class="tag">db2</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/eladmin/"><span class="tag">eladmin</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/es/"><span class="tag">es</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/githubpage/"><span class="tag">githubpage</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/linux/"><span class="tag">linux</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/nginx/"><span class="tag">nginx</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/redis/"><span class="tag">redis</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/sql/"><span class="tag">sql</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vue/"><span class="tag">vue</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%B0%8F%E5%AD%A6%E7%94%9F%E4%BD%9C%E6%96%87-%E6%88%91%E7%9A%84%E7%94%9F%E6%B4%BB/"><span class="tag">小学生作文-我的生活</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%AE%97%E6%B3%95/"><span class="tag">算法</span><span class="tag">1</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">Zeroornull</a><p class="is-size-7"><span>&copy; 2022 Zeroornull</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><a href="http://www.beian.miit.gov.cn/" target="_blank">皖ICP备2021011041号-1</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>